/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TRooFit/TRooHF1.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "RooAbsLValue.h"
#include "RooRealVar.h"
#include "RooProdPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooProduct.h"
#include "RooAddition.h"
#include "RooConstVar.h"

#include "RooDataSet.h"
#include "RooDataHist.h"

#include "RooNumIntConfig.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"

#include "RooCachedReal.h"

#include "RooBinning.h"

#include "TRooFit/TRooHStack.h"

#include <memory>

#include "TGraphErrors.h"

ClassImp(TRooHF1) 



TRooHF1::TRooHF1(const char* name, const char* title) : TRooHF1(name,title,RooArgList(),{},{},{}) {}
TRooHF1::TRooHF1(const char *name, const char *title,const RooArgList& observables, const int* bins, const double* min, const double* max ) : TRooHF1(name,title,observables,bins,min,max,{},0) {}
TRooHF1::TRooHF1(const char *name, const char *title,const RooArgList& observables, std::vector<int>&& bins, std::vector<double>&& min, std::vector<double>&& max ) : 
  TRooHF1(name,title,observables,&bins[0],&min[0],&max[0],{},0) {}
TRooHF1::TRooHF1(const char *name, const char *title, const RooArgList& observables, TH1* hist) :
    TRooHF1(name,title,observables,0,0,0,{},hist) {}
TRooHF1::TRooHF1(const char *name, const char *title, 
                        const RooArgList& observables, std::vector<int>&& bins, std::vector<const Double_t*>&& binEdges ) : TRooHF1(name,title,observables,&bins[0],0,0,std::move(binEdges),0) {}

TRooHF1::TRooHF1(const char *name, const char *title, const RooArgList& observables, const int* bins, const double* min, const double* max, std::vector<const Double_t*>&& binEdges, TH1* hist) :
   RooAbsReal(name,title), TRooAbsH1(observables,this),
   fParameters("!pars","pars",this),
   fValues("!vals","!vals",this)
   
{ 
  //Only experts should construct TRooHF1 directly. Please use derived classes (e.g. TRooHF1D)

 
  //add binning to the continuous observables
  //also store the binnings and category sizes
  int j=0;
  for(int i=0;i<fObservables.getSize();i++) {
    if(fObservables[i].IsA() == RooRealVar::Class()) {
      if(hist) {
        if(hist->GetXaxis()->GetXbins()->GetArray()) {
          static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(hist->GetXaxis()->GetNbins(),hist->GetXaxis()->GetXbins()->GetArray()),name );
        } else {
          static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),hist->GetXaxis()->GetNbins()),name);
        }
      } else if(min==0) {
        static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(bins[j],binEdges[j]),name);
      } else {
        static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(min[j],max[j],bins[j]),name);
      }
      j++;
    } else if(fObservables[i].IsA() == RooCategory::Class()) {
      RooCategory& cat = static_cast<RooCategory&>(fObservables[i]);
      std::unique_ptr<TIterator> itr( cat.typeIterator() );
      RooCatType* tt = 0;
      while( (tt = (RooCatType*)itr->Next()) ) {
        cat.addToRange(GetName(),tt->GetName());
      }
    }
  }
  
//   //update axis in parent TH1
//   fNCells = 1;
//   switch(fObservables.getSize()) {
//     case 3: fZaxis.Set(bins[2],min[2],max[2]); fNCells *= (bins[2]+2);
//     case 2: fYaxis.Set(bins[1],min[1],max[1]); fNCells *= (bins[1]+2);
//     case 1: fXaxis.Set(bins[0],min[0],max[0]); fNCells *= (bins[0]+2);
//   }
//   fDimension=fObservables.getSize();
  
  if(hist) {
       //FIXME: should do checks on hist dimensions 
      fHists.push_back( (TH1*)hist->Clone(name) );
      fHists[0]->SetDirectory(0);fHists[0]->Reset(); //clears it 
      Add( hist ); //adds it, so that stat factors are created 
  } else {
  
    //create the default hist
    if(fObservables.getSize()==0) {
      fHists.push_back( new TH1D(name,title,1,-0.5,0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
    } else if(fObservables.getSize()==1) {
      if(fObservables[0].IsA() == RooCategory::Class()) { 
        RooCategory& cat = static_cast<RooCategory&>(fObservables[0]);
        fHists.push_back( new TH1D(name,title,cat.numTypes(),-0.5,cat.numTypes()-0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      } else {
        if(min==0) {
          fHists.push_back( new TH1D(name,title,bins[0],binEdges[0]) );
        } else {
          fHists.push_back( new TH1D(name,title,bins[0],min[0],max[0]) );
        }
        fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      }
      specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
    } else if(fObservables.getSize()==2) {
      if(min==0) {
        fHists.push_back( new TH2D(name,title,bins[0],binEdges[0],bins[1],binEdges[1]) );
      } else {
        fHists.push_back( new TH2D(name,title,bins[0],min[0],max[0],bins[1],min[1],max[1]) );
      }
      fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    } else {
      std::cout << "not supported!" << std::endl;
    }
  }
 
  fParameterSnapshots.resize(1); //creates an empty vector
  fDummyHist = fHists[0];fDummyHist->GetXaxis()->SetTitle("");fDummyHist->GetYaxis()->SetTitle("");
  setAttribute("NeverConstant",true); //stops these objects being 'cached' away, because they rarely should be
  RooMsgService::instance().getStream(RooFit::INFO).removeTopic(RooFit::NumIntegration); //stop info message every time
} 


TRooHF1::TRooHF1(const TRooHF1& other, const char* name) :  
   RooAbsReal(other,name), TRooAbsH1(other,this),
   fParameters(other.fParameters.GetName(),this,other.fParameters),
   fValues(other.fValues.GetName(),this,other.fValues),
   fHists(other.fHists),
   fFunctionalBinValues(other.fFunctionalBinValues),
   fParameterSnapshots(other.fParameterSnapshots),
   fInterpCode(other.fInterpCode),fObsInterpCode(other.fObsInterpCode)
{
  //Copy constructor
}




bool TRooHF1::addParameter( RooAbsArg& arg , int interpCode ) { 
  //Use this method to turn this TRooFit histogram into a function of the given parameter, arg.
  //All the previously filled values of the histogram will be assumed to correspond 
  //to the current value of the parameter 
  //
  //You can then change the value of the parameter and start to re-fill the histogram 
  //This will then make the histogram correspond to a coherent variation. 
  //
  //The interpCode determines the interpolation between parameter points .
  //See TRooHF1::setInterpCode for description of different options.
  //Default interpCode (0) is piecewise linear interpolation
  //

  if(fParameters.find(arg)) return false; //already added
  
  
  
  fParameters.add(arg); fParameters.setName("pars"); fInterpCode.push_back(interpCode);
  if(fMissingBin) fMissingBin->addParameter(arg, interpCode);
  //add a clone to all existing paramsets too
  double val = (arg.InheritsFrom(RooAbsCategory::Class())) ? static_cast<RooAbsCategory&>(arg).getIndex() : static_cast<RooAbsReal&>(arg).getVal();
  for(auto& pars : fParameterSnapshots) {
    pars.push_back(val);
  }
  
  //need to also tell all clients that we have a new parameter to depend on
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->addServer(arg);client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}



Bool_t TRooHF1::Add(const TH1* h1 , Double_t c1) {
  //Add a histogram to this TRooHF1, i.e. fill the content of h1 into this TRooHF1
  //includes the optional scaling factor c1

  int pset = getOrCreateParamSet();
  bool out = fHists[pset]->Add(h1,c1);
  
  if(out && pset==0) { //add succeeded, and was adding to 'nominal' set, so adjust stat factors
    for(int i=1;i<=h1->GetNbinsX();i++) {
      for(int j=1;j<=h1->GetNbinsY();j++) {
        for(int k=1;k<=h1->GetNbinsZ();k++) {
          int bin = h1->GetBin(i,j,k);
          if(!h1->GetBinError(bin)) continue; //don't need to adjust if there was no error
          RooRealVar* statFactor = getStatFactor(bin); //first try without creating 
          if(!statFactor) { 
            statFactor = getStatFactor(bin, true);  //automatically sets sumw and sumw2 for us when creating a new statFactor
          } else {
            //update the sumw and sumw2 attribute of the stat factor
            statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() + h1->GetBinContent(bin)*c1)));
            statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() + pow(h1->GetBinError(bin)*c1,2))));
            //will also set the error to sqrt(sumw2)/sumw
            statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
            if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
          }
        }
      }
    }
  }
  return out;
}


Int_t TRooHF1::Fill( double x , double w ) {
  //The usual histogram Fill method
  //This method will trigger the automatic creation of parameters (as necessary) 
  // to represent the statistical uncertainty in the filled bin 

  int pset = getOrCreateParamSet();
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { w = x; x = 0; } //in the counting-mode, the x variable is always "0"
  
  //only create stat factors when filling the 'nominal' histogram
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin, true);
    //update the sumw and sumw2 attribute of the stat factor
    statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() + w)));
    statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() + w*w)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    
  }
  

  
  
  return fHists[pset]->Fill(x,w);
  
  //FIXME: propagate changes to transFactor if there is one!
  
}

Int_t TRooHF1::Fill( const char* name , double w ) {
  //Same as above, but can use name of Category type
  
  if(GetDimension()==0) return Fill(0.,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("Fill","%s is not a category, cannot fill",fObservables[0].GetName());
    return -1;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("Fill","%s unknown label in %s",name,fObservables[0].GetName());
    return -1;
  }
  return Fill( type->getVal() , w );
  
}

  
Int_t TRooHF1::Fill( Double_t x, RooAbsReal& val ) {
  //Fills (i.e. adds) a function to bin at x value, 
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { bin = -1; } 
  
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return fValues.index(&val);
  
}


Int_t TRooHF1::Fill( RooAbsReal& val ) {
  //fill every bin with this function
  
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
    
  fFunctionalBinValues[-1].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return 0;
  
}


Int_t TRooHF1::getOrCreateParamSet() {
  //Internal method used when updating the content of the TRooHF1
  //e.g. in SetBinContent, Fill, SetBinError, etc

  setValueDirty();
  //we have to dirty up ALL clients, not just those who have said they are value clients
  //integrals don't think of themselves as value clients because they think they integrate out changes in our value
  //i.e. they assume the only way a function can change value is if the servers change values
  //and so the only way THEY can change value is if the non-integrated servers change value
  
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  

  int pset = getParamSet();
  
  if(pset==-1) { //need to create a new hist, clone the "nominal" hist
    std::vector<double> parVals;
    //get the current paramter values
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      if(par->InheritsFrom( RooAbsCategory::Class() )) {
        parVals.push_back( ((RooAbsCategory*)par)->getIndex() );
      } else {
        parVals.push_back( ((RooAbsReal*)par)->getVal() );
      }
    }
    fParameterSnapshots.push_back(parVals);
    fHists.push_back( (TH1*)fHists[0]->Clone( Form("%s_variation%d",GetName(),int(fParameterSnapshots.size()))) ); 
    fHists.back()->SetDirectory(0);
    fHists.back()->Reset();
    pset = fParameterSnapshots.size()-1;
    
    
  }
  return pset;
}

bool TRooHF1::setInterpCode(const char* parName, int code) {
  //Set interpolation code for a given parameter or observable
  //
  //Observables:
  // 0 = binned (default behaviour) 
  // 1 = linear interpolation between each bin 
  //
  //Parameters:
  // 0 = piecewise linear 
  // 2 = 6th order polynominal with log extrapolation (should match code 4, but this implemented differently)
  // 3 = 6th order polynominal with linear extrapolation (Like HistFactory::PiecewiseInterpolation's code 4)
  // 4 = 6th order polynominal with log extrapolation (Like HistFactory::FlexibleInterpVar's code 4)
  //
  //Note that in all cases, if only one variation (parameter space point) is provided for the given parameter
  //then straightforward linear interpolation is used. 
  //
  //Returns true on success


  int idx = fParameters.index(parName);
  if(idx==-1) {
    //check observables 
    idx = fObservables.index(parName);
    if(idx==-1) return false;
    if(code==0 && (fObsInterpCode&(1<<idx))) fObsInterpCode -= (1<<idx);
    else if( (fObsInterpCode&(1<<idx)) ==0) fObsInterpCode += (1<<idx);
  } else {
    fInterpCode[idx] = code;
  }
  
  //make everything dirty
  setValueDirty();
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}

bool TRooHF1::setInterpCode(const RooAbsArg& arg, int code) {
  //Same as above, but can pass the actual argument 
  //
  return setInterpCode(arg.GetName(),code);
}

void TRooHF1::SetBinContent( int bin, double val ) {
  //Set the contents of a given bin

  int pset = getOrCreateParamSet();
  //update the statFactor's sumw, if necessary
  if(pset==0 && fHists[pset]->GetBinContent(bin)) {
    RooRealVar* statFactor = getStatFactor(bin);
    if(statFactor) {
      statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() - fHists[pset]->GetBinContent(bin) + val)));
      //will also set the error to sqrt(sumw2)/sumw
      statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
      if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    }
  }
  fHists[pset]->SetBinContent(bin,val);
  //FIXME: propagate changes to transFactor if there is one!
}

void TRooHF1::SetBinContent( const char* name , double w ) {
  //Set the contents of a given bin 
  //The first observable of this TRooHF1 must be a RooCategory

  //first observable must be a category
  if(GetDimension()==0) SetBinContent(1,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("SetBinContent","%s is not a category, cannot fill",fObservables[0].GetName());
    return;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("SetBinContent","%s unknown label in %s",name,fObservables[0].GetName());
    return;
  }
  SetBinContent( type->getVal() + 1 , w );
  
}

void TRooHF1::SetBinContent( int bin, RooAbsReal& val ) {
  //Sets the bin content equal to a function value 
  
  SetBinContent(bin,0.); //clears existing content 
  
  if(fValues.index(&val)==-1) fValues.add(val);
  if(fObservables.getSize()==0) { bin = -1; } 
  
  fFunctionalBinValues[bin].clear(); //removes existing values 
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  
}



void TRooHF1::SetBinError( int bin, double error ) {
  //Set the error of the given bin
  //If a statFactor for the bin does not already exist, it will be created

  int pset = getOrCreateParamSet();
  
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin,true);
    //update the sumw2 attribute of the stat factor ... 
    //the factor might be shared if its in a stack, so must subtract old error and add new one
    statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() - pow(fHists[pset]->GetBinError(bin),2) + error*error)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
  } else {
    Warning("SetBinError","Bin errors only used when in nominal histogram");
  }
  
  fHists[pset]->SetBinError(bin,error);
  
}


Int_t TRooHF1::getParamSet() const {
  //Returns the ID of the current parameter spacepoint 
  //Or if the state of the parameters is an unknown point
  //then this method will return -1.

  if(fParameters.getSize()==0) return 0;
  
  //compare parameter values up to a certain 'precision' for equality
  int i=0;
  for(auto& parVals : fParameterSnapshots) {
    bool match(true);
    
    uint j=0;
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
      double val = 0;
      if(cat) {
        val = cat->getIndex();
      } else {
        val = static_cast<RooAbsReal*>(par)->getVal();
      }
      if( fabs(val - parVals[j]) > 1e-9 ) {match=false;break;}
      j++;
    }
    if(match) return i;
    i++;
  }
  
  return -1;
}


const std::vector<double>& TRooHF1::GetParamSet(int idx) const { 
  //Return the values of the parameters corresponding to paramSet = idx
  //The order of the parameters can be seen through the Print method 
  
  return fParameterSnapshots[idx]; 
}

Double_t TRooHF1::evaluate() const 
{
  //The main roofit evaluation method. Users should not call this directly 
  //It is computing the pdf value (the probability density) 

//std::cout << "rangeName = " << GetRangeName() << " "; fObservables.Print("v"); 

  double out = 0;
  int bin = getBin(GetName()); //forcefully use OUR binning 



    //loop over parameter snapshots, assessing which sets are valid (discrete params must match exactly)
    //if we find an exact match, we go with that
    
    //goal is that for each parameter to obtain the spacepoint IDs for the two closest valid spacepoints
    
    std::vector<int> upSet(fParameters.getSize(),-1); 
    std::vector<int> downSet(fParameters.getSize(),-1); 
    int nomSet = -1;
    
    int pset=-1;
    if(fParameters.getSize()==0) { 
      pset=0;
    } else {
    
      int i=0;
      std::vector<int> setUp;std::vector<int> setDown; //get filled with parameter indices that should get set to up/down
      for(auto& parVals : fParameterSnapshots) {
        bool match(true); bool invalid(false);
        RooFIter parItr(fParameters.fwdIterator());
        int j=0; 
        setUp.clear();setDown.clear();
        while(auto par = parItr.next() ) {
          RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
          if(cat) {
            if( cat->getIndex() != int(parVals[j]+0.5) ) {
              match=false;invalid=true;break;
            }
          } else {
            //record if this is up/down/nom variation for this parameter
            double parVal = ((RooAbsReal*)par)->getVal();
            double parDiff = fabs(parVal - parVals[j]);
            if(parDiff > 1e-9) {
              match=false;
              if(nomSet==-1) continue; //don't use the nomSet as our up-vs-down set
              //check parVals[j] is different to fParameterSnapshots[0][j] ... i.e. that this is a variation for parameter j
              if(fabs(parVals[j]-fParameterSnapshots[0][j])>1e-9) {
                if(upSet[j]==-1) setUp.push_back(j); //if valid, will
                else if(downSet[j]==-1) setDown.push_back(j);
                else {
                  //replace the one that is further away 
                  double upDiff = fabs(fParameterSnapshots[upSet[j]][j] - parVal);
                  double downDiff = fabs(fParameterSnapshots[downSet[j]][j] - parVal);
                  if(parDiff<upDiff || parDiff<downDiff) {
                    if(upDiff>downDiff) setUp.push_back(j);
                    else setDown.push_back(j);
                  }
                }
              }
            }
          }
          j++;
        }
        if(match) {
          pset=i; 
          break; //can just stop right now, found a perfect match
        }
        if(!invalid) { //if snapshot featured a variation up or down, store that
          if(nomSet==-1) nomSet=i; //the first valid set is used as the nom set
          //signal which parameters this snapshot is a valid variation for
          for(auto& j : setUp) upSet[j]=i;
          for(auto& j : setDown) downSet[j]=i;
        }
        i++;
      }
    }
    
    //add the functional bin values
    if(fFunctionalBinValues.find(-1)!=fFunctionalBinValues.end()) {
      for(auto& vals : fFunctionalBinValues.at(-1)) {
        //warning: dont want to use getVal(_normSet) because we've added a pdf, not necessarily added a NORMALIZED pdf
        out += static_cast<RooAbsReal&>(fValues[vals]).getVal(); //if function is a pdf, we assume it is already a density!
      }
    }
    if(fFunctionalBinValues.find(bin) != fFunctionalBinValues.end()) {
      for(auto& vals : fFunctionalBinValues.at(bin)) {
        out += static_cast<RooAbsReal&>(fValues[vals]).getVal(); 
      }
    }
    

    if(pset!=-1) {
      //add the raw values too
      TH1* hist = GetHist(pset);
      
      //calculate bin volume, only if necessary though .. 
      double val(0);
      if(fObsInterpCode) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        switch(hist->GetDimension()) {
          case 1: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] )); break;
          case 2: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ) ); break;
          case 3: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ),
                                     (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hist->GetYaxis()->GetBinCenter( bb[2] ) ); break;
        }
      } else {
         val = hist->GetBinContent(bin);
      }
      out += val;
    } else if(nomSet!=-1) { //can only interpolate when there's a valid parameter spacepoint
      //got here, must interpolate
      //loop over parameters, and use upSet and downSet to compute interpolated result
      TH1* hist = GetHist(nomSet);
      double nomVal(0);
      if(fObsInterpCode) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        switch(hist->GetDimension()) {
          case 1: nomVal = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] )); break;
          case 2: nomVal = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ) ); break;
          case 3: nomVal = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ),
                                     (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hist->GetYaxis()->GetBinCenter( bb[2] ) ); break;
        }
      } else {
        nomVal = hist->GetBinContent(bin);
      }
      double val = nomVal;

      RooFIter parItr(fParameters.fwdIterator());
      int i=-1;
      while(auto par = parItr.next() ) {
        i++;
        if(par->InheritsFrom( RooAbsCategory::Class() ) ) continue;
        if(upSet[i]==-1) continue; //no variation for this parameter (need at least a point)
        
        //now calculate the value based on interpolation between these two points 
        double y_up(0);
        double y_down(nomVal);
        if(fObsInterpCode) {
          TH1* hh = GetHist( upSet[i] );
          int bb[3]; hh->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
          switch(hh->GetDimension()) {
            case 1: y_up = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] )); break;
            case 2: y_up = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                      (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ) ); break;
            case 3: y_up = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                      (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ),
                                      (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hh->GetYaxis()->GetBinCenter( bb[2] ) ); break;
          }
          if(downSet[i]!=-1) {
            hh = GetHist( downSet[i] );
            switch(hh->GetDimension()) {
              case 1: y_down = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] )); break;
              case 2: y_down = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                        (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ) ); break;
              case 3: y_down = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                        (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ),
                                        (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hh->GetYaxis()->GetBinCenter( bb[2] ) ); break;
            }
          }
          
        } else {
          y_up = GetHist( upSet[i] )->GetBinContent(bin);
          if(downSet[i]!=-1) y_down = GetHist( downSet[i] )->GetBinContent(bin);
        }
        double x_up = fParameterSnapshots[upSet[i]][i];
        double x_val = ((RooAbsReal*)par)->getVal();
        
        
        bool doCode2(false);
        switch(fInterpCode[i]*(downSet[i]!=-1)) {
        case 0:{ //piecewise linear always used if only one variation
             //if downSet unavailable, use nominal set as the down variation
            double x_down = (downSet[i]==-1) ? fParameterSnapshots[nomSet][i] : fParameterSnapshots[downSet[i]][i];
            double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
            val += (tmpVal - nomVal);
            }break;
        case 2: //6th order poly with log extrapolation 
            doCode2=true;
        case 3:{ //6th order poly with linear extrapolation
            double x_down = fParameterSnapshots[downSet[i]][i];
            
            if(x_val < x_down && x_val < x_up) {
              if(doCode2) {
                val *= (x_down < x_up) ? std::pow(y_down/nomVal, x_val/x_down) : std::pow(y_up/nomVal, x_val/x_up);
              } else {
                //linear extrapolate from x_val and x_down or x_up, whichever is lower 
                if(x_down < x_up) {
                  y_up = nomVal; x_up = fParameterSnapshots[nomSet][i];
                } else {
                  y_down = nomVal; x_down = fParameterSnapshots[nomSet][i];
                }
                double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
                val += (tmpVal - nomVal);
              }
            } else if(x_val > x_up && x_val > x_down) {
              if(doCode2) {
                val *= (x_down < x_up) ? std::pow(y_up/nomVal, x_val/x_up) : std::pow(y_down/nomVal, x_val/x_down);
              } else {
                //linear extrapolate from x_val and x_down or x_up, whichever is lower 
                if(x_down < x_up) {
                  y_down = nomVal; x_down = fParameterSnapshots[nomSet][i];
                } else {
                  y_up = nomVal; x_up = fParameterSnapshots[nomSet][i];
                }
                double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
                val += (tmpVal - nomVal);
              }
            } else {
              //Code based off what is in HistFactor::PiecewiseInterpolation (interpCode 4)
            
              //scale and shift x values so x_up-x_down = 2 and x_up+x_down=0 (i.e. usual +1, -1 case) 
              //sf even flips x_up and x_down so that x_up > x_down
              //std::cout << "x_val =" << x_val << " x_up=" << x_up << " x_down=" << x_down << std::endl;
              double sf = 2.0/(x_up-x_down);
              x_val *= sf; x_up *= sf; x_down *= sf;
              double sh = (x_up+x_down)/2.0;
              x_val -= sh; 
              double eps_plus = y_up-nomVal; double eps_minus=nomVal-y_down;
              double S = 0.5 * (eps_plus + eps_minus);
              double A = 0.0625 * (eps_plus - eps_minus);
              val += x_val * (S + x_val * A * ( 15 + x_val * x_val * (-10 + x_val * x_val * 3  ) ) );
            }
                    
            }break;
        case 4:{ //6th order polynomial with log extrapolation
            double x_down = fParameterSnapshots[downSet[i]][i];
        
        
            //scale and shift x values so x_up-x_down = 2 and x_up+x_down=0 (i.e. usual +1, -1 case) 
            //sf even flips x_up and x_down so that x_up > x_down
            
            //std::cout << "x_val =" << x_val << " x_up=" << x_up << " x_down=" << x_down << std::endl;
            double sf = 2.0/(x_up-x_down);
            x_val *= sf; x_up *= sf; x_down *= sf;
            double sh = (x_up+x_down)/2.0;
            x_val -= sh; //x_up -= sh; x_down -= sh; //... x_up and x_down should equal 1 and -1 by this point
            
        
            if(x_val >= 1.) {
              val *= std::pow(y_up/nomVal, x_val);
            } else if(x_val <= -1.) {
              val *= std::pow(y_down/nomVal, -x_val);
            } else if(x_val) {
              //Based off what is in FlexibleInterpVar (interpCode 4)
              
              //coefficients can be precomputed, but are function of nomSet, upSet, downSet indices, bin, and i
              
              double coeff[6];
              
              double pow_up       =  y_up/nomVal;
              double pow_down     =  y_down/nomVal;
              double logHi        =  std::log(pow_up) ; //BUGFIXED!
              double logLo        =  std::log(pow_down); //BUGFIXED!
              double pow_up_log   = y_up <= 0.0 ? 0.0 : pow_up * logHi;
              double pow_down_log = y_down <= 0.0 ? 0.0 : -pow_down    * logLo;
              double pow_up_log2  = y_up <= 0.0 ? 0.0 : pow_up_log  * logHi;
              double pow_down_log2= y_down <= 0.0 ? 0.0 : -pow_down_log* logLo;
      
              double S0 = (pow_up+pow_down)/2;
              double A0 = (pow_up-pow_down)/2;
              double S1 = (pow_up_log+pow_down_log)/2;
              double A1 = (pow_up_log-pow_down_log)/2;
              double S2 = (pow_up_log2+pow_down_log2)/2;
              double A2 = (pow_up_log2-pow_down_log2)/2;
              
              //fcns+der+2nd_der are eq at bd
              
              // cache  coefficient of the polynomial 
              coeff[0] = 1./(8)        *(      15*A0 -  7*S1 + A2);
              coeff[1] = 1./(8)     *(-24 + 24*S0 -  9*A1 + S2);
              coeff[2] = 1./(4)*(    -  5*A0 +  5*S1 - A2);
              coeff[3] = 1./(4)*( 12 - 12*S0 +  7*A1 - S2);
              coeff[4] = 1./(8)*(    +  3*A0 -  3*S1 + A2);
              coeff[5] = 1./(8)*( -8 +  8*S0 -  5*A1 + S2);
              
              
              val *= (1. + x_val * (coeff[0] + x_val * (coeff[1] + x_val * (coeff[2] + x_val * (coeff[3] + x_val * (coeff[4] + x_val * coeff[5]) ) ) ) ) );
              
            }
            
            
            }break;
        }

        
      }

      out += val;
    }

  
  //multiply by all the norm factors
  RooFIter itr(fNormFactors.fwdIterator());
  while( RooAbsReal* arg = (RooAbsReal*)itr.next() ) out *= arg->getVal(); //NOTE: should we use _normSet? leads to issues if normfactor is a pdf...
  
  //and by the shape factors for this bin
  if(fBinsShapeFactors.find(bin)!=fBinsShapeFactors.end()) {
    for(auto& sfIdx : fBinsShapeFactors.at(bin)) {
      out *= ((RooAbsReal&)fShapeFactors[sfIdx]).getVal();
    }
  }
  
  return out;
  
}





//these functions are needed by the RooBinIntegrator
std::list<Double_t>* TRooHF1::binBoundaries(RooAbsRealLValue& obs, Double_t xlow, Double_t xhi) const {

  auto binning = obs.getBinningPtr(GetName()); //always use our own binning when integrating!
  std::list<Double_t>* out = new std::list<Double_t>;
  
  for(int i=0;i<binning->numBins();i++) {
    double binEdgeLow = binning->binLow(i);
    double binEdgeHigh = binning->binHigh(i);
    
    //if any overlap then we include
    if(binEdgeLow > xhi) break; //finished
    
    if(binEdgeHigh > xlow) {
      if(out->size()==0) out->push_back(binEdgeLow);
      out->push_back(binEdgeHigh);
    }
    
  }
  return out;
}

Bool_t TRooHF1::isBinnedDistribution(const RooArgSet& obs) const {
  //if all obs are in the fObservables, then we are binnined
  RooFIter itr = obs.fwdIterator();
  while( RooAbsArg* arg = itr.next() ) {
    if(!fObservables.find(*arg)) return kFALSE;
  }
  return kTRUE;
}
