/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TRooFit/TRooH1.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "RooAbsLValue.h"
#include "RooRealVar.h"
#include "RooProdPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooProduct.h"
#include "RooAddition.h"
#include "RooConstVar.h"

#include "RooDataSet.h"
#include "RooDataHist.h"

#include "RooNumIntConfig.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"

#include "RooCachedReal.h"

#include "RooBinning.h"

#include "TRooFit/TRooHStack.h"

#include <memory>

#include "TGraphErrors.h"

ClassImp(TRooH1) 
ClassImp(TRooH0D) 


TRooH1::TRooH1(const TRooH1& other, const char* name) :  
   RooAbsPdf(other,name), TRooAbsH1Fillable(other,this)
{
  //Copy constructor
}





void TRooH1::FillMissing(double w) {
  //Fill (i.e. adds to) the content of the 'missing events' bin 
  
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->Fill(w);
}


void TRooH1::SetMissingContent(double w) {
  //Set the content of the 'missing events' bin
  //This is held in a separate 0-bin TRooH1 (i.e. a TRooH0D)
  
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->SetBinContent(1,w);
}

void TRooH1::SetMissingError(double w) {
  //Set the error of the 'missing events' bin 
  //If a statFactor for the bin does not already exist, it will be created 
  
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->SetBinError(1,w);
}



Double_t TRooH1::expectedEvents(const RooArgSet* nset) const { 
  //Effectively corresponds to the integral of the TRooH1 over the 
  //observables provided in nset. 
  //
  //If you want the error on the integral, you should instead 
  //create a RooFit function that represents the integral 
  //You can do this with RooAbsReal::createIntegral
  //
  //If you want the integral to include the 'missing events' total 
  //you should use TRooAbsH1::createIntegralWM , which will return a 
  //RooAddition containing the missing event totals
  //
  //Once you have this RooFit function, you can propgate errors the usual way
  //using getPropagatedError

 if(nset==0/* || !dependsOn(*nset)*/) {
  //std::cout << " expected event 0 = " << getBinContent() << std::endl; 
  //return getBinContent(); //use the raw value for expected events
  return 1; //return 1 so that getBinContent is not messed up
 }
 double out = getNorm(nset);
 //std::cout << "expected events = " << out << std::endl;
 return out;
}





//_____________________________________________________________________________
Bool_t TRooH1::syncNormalization(const RooArgSet* nset, Bool_t adjustProxies) const
{
  using namespace std;
  // Verify that the normalization integral cached with this PDF
  // is valid for given set of normalization observables
  //
  // If not, the cached normalization integral (if any) is deleted
  // and a new integral is constructed for use with 'nset'
  // Elements in 'nset' can be discrete and real, but must be lvalues
  //
  // For functions that declare to be self-normalized by overloading the
  // selfNormalized() function, a unit normalization is always constructed


//   cout << IsA()->GetName() << "::syncNormalization(" << GetName() << ") nset = " << nset << " = " << (nset?*nset:RooArgSet()) << endl ;

  _normSet = (RooArgSet*) nset ;
  //std::cout << "incoming = " << nset << std::endl;
  // Check if data sets are identical
  
  //for(int i=0; i < _normMgr._nsetCache.size();i++) {
  //  std::cout << "0cache nset (" << i << ") size=" << _normMgr._nsetCache[i].entries() << " index=" << _normMgr._nsetCache[i].index(nset,0,0) << std::endl;
  //}
  
  _normMgr._owner = 0; //dirty hack to stop autoCache method calling getObservables on me
  CacheElem* cache = (CacheElem*) _normMgr.getObj(nset) ;
  _normMgr._owner = (TRooH1*)this; //dirty hack to stop autoCache method calling getObservables on me
  
  
  //for(int i=0; i < _normMgr._nsetCache.size();i++) {
  //  std::cout << "cache nset (" << i << ") size=" << _normMgr._nsetCache[i].entries() << " index=" << _normMgr._nsetCache[i].index(nset,0,0) << std::endl;
  //}
  
  if (cache) {
    //check that variables integrated over matches
    //std::cout << "got cache " << cache->_norm->GetName() << " for (" << nset << ") : "; nset->Print();
    //std::cout << "value = " << cache->_norm->getVal() << std::endl;
    Bool_t nsetChanged = (_norm!=cache->_norm) ;
    _norm = cache->_norm ;


//      cout << "returning existing object " << _norm->GetName() << endl ;

    if (nsetChanged && adjustProxies) {
      // Update dataset pointers of proxies
      ((TRooH1*) this)->setProxyNormSet(nset) ;
    }
  
    return nsetChanged ;
  }
    
  // Update dataset pointers of proxies
  if (adjustProxies) {
    ((TRooH1*) this)->setProxyNormSet(nset) ;
  }
  
  //NOTE: an alternative to this 'depend on all observables' approach (where to auto extend uniformly in unknown observables)
  //would be to modify the unit normalization return below to be replaced by SELF VALUE
  //could use a RooFormulaVar for this, I guess, or a RooAddition with just ourself in the func list
  
  RooArgSet* depList = getObservables(nset); //(nset) ? new RooArgSet(*nset) : new RooArgSet;//WB integrate over all variables!! getObservables(nset) ;
  //depList->Print();

  if (_verboseEval>0) {
    if (!selfNormalized()) {
      cxcoutD(Tracing) << IsA()->GetName() << "::syncNormalization(" << GetName() 
	   << ") recreating normalization integral " << endl ;
      if (depList) depList->printStream(ccoutD(Tracing),kName|kValue|kArgs,kSingleLine) ; else ccoutD(Tracing) << "<none>" << endl ;
    } else {
      cxcoutD(Tracing) << IsA()->GetName() << "::syncNormalization(" << GetName() << ") selfNormalized, creating unit norm" << endl;
    }
  }

  // Destroy old normalization & create new
  if (selfNormalized()/* || !dependsOn(*depList)*/) {    
    TString ntitle(GetTitle()) ; ntitle.Append(" Unit Normalization") ;
    TString nname(GetName()) ; nname.Append("_UnitNorm") ;
    _norm = new RooRealVar(nname.Data(),ntitle.Data(),1) ;
  } else {    
    const char* nr = (_normRangeOverride.Length()>0 ? _normRangeOverride.Data() : (_normRange.Length()>0 ? _normRange.Data() : 0)) ;

//     cout << "RooAbsPdf::syncNormalization(" << GetName() << ") rangeName for normalization is " << (nr?nr:"<null>") << endl ;
    RooAbsReal* normInt = createIntegral(*depList,*getIntegratorConfig(),nr) ;
    normInt->getVal() ;
//     cout << "resulting normInt = " << normInt->GetName() << endl ;

    const char* cacheParamsStr = getStringAttribute("CACHEPARAMINT") ;
    if (cacheParamsStr && strlen(cacheParamsStr)) {
      
      RooArgSet* intParams = normInt->getVariables() ;
      
      RooNameSet cacheParamNames ;
      cacheParamNames.setNameList(cacheParamsStr) ;
      RooArgSet* cacheParams = cacheParamNames.select(*intParams) ;
      
      if (cacheParams->getSize()>0) {
	cxcoutD(Caching) << "RooAbsReal::createIntObj(" << GetName() << ") INFO: constructing " << cacheParams->getSize()
			 << "-dim value cache for integral over " << *depList << " as a function of " << *cacheParams << " in range " << (nr?nr:"<default>") <<  endl ;
	string name = Form("%s_CACHE_[%s]",normInt->GetName(),cacheParams->contentsString().c_str()) ;
	RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,*cacheParams) ;
	cachedIntegral->setInterpolationOrder(2) ;
	cachedIntegral->addOwnedComponents(*normInt) ;
	cachedIntegral->setCacheSource(kTRUE) ;
	if (normInt->operMode()==ADirty) {
	  cachedIntegral->setOperMode(ADirty) ;
	}
	normInt= cachedIntegral ;
      }
      
      delete cacheParams ;
      delete intParams ;
    }
    _norm = normInt ;    
  }
  
  // Register new normalization with manager (takes ownership)
  cache = new CacheElem(*_norm) ;
  _normMgr._owner = 0; //dirty hack to stop autoCache method calling getObservables on me
  _normMgr.setObj(nset,cache) ;
  _normMgr._owner = (TRooH1*)this; //dirty hack to stop autoCache method calling getObservables on me
  
//   cout << "making new object " << _norm->GetName() << endl ;

  delete depList ;
  return kTRUE ;
}

/*
Int_t TRooH1::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName) const {
  //for now, only worry about NormFactor depending on an observable that we are integrating on
  
  //we must end up copying to analVars the observables that a norm factor also depends on
  //for now we will do just 1D case
  
  auto integratingObs = fObservables.selectCommon(allVars);
  if(integratingObs->getSize()==0) { delete integratingObs; return 0; }
  RooFIter nf = fNormFactors.fwdIterator();
  RooAbsArg* arg; bool found(false);
  while( (arg = nf.next()) ) {
    if(arg->dependsOn(*integratingObs)) {
      found=true; //for now, if not found then fallback on integrator
      std::cout << " found= " << arg->GetName() << std::endl;
      analVars.add(*integratingObs); break; //for now just stop immediately ... could in future use the return code to say which normfactor is dependent
    }
  }
  
  
  delete integratingObs; return found;
  
  //note that if no factors depend on observables, roofit will just fall back on our declared BinIntegrator!
  
}
 
Double_t TRooH1::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const {

  //got here, so must have a normFactor that depends on observables
  //we will need to step through our bins, get our val and multiply it by the integrals of any dependent normfactor
  //remember to divide out the included norm factor value: FIXME: what if the normfactor is 0 at evaluation point, but nonzero in other parts of bin!?
  
  if(code==0) return getBinContent();
  
  std::cout << "got code " << code << std::endl;
  
  //FIXME: we assume 1D case for now!
  
  RooFIter nf = fNormFactors.fwdIterator();
  RooAbsReal* arg;
  RooArgList dependentNf;
  RooArgList dependentNfIntegrals;
  TString intRange = Form("%s_intRange",GetName()); //we will change this range to match the bin edges as we loop over bins
  while( (arg = (RooAbsReal*)nf.next()) ) {
    if(arg->dependsOn(fObservables)) {
      dependentNf.add(*arg);
      dependentNfIntegrals.addOwned( *arg->createIntegral( RooArgSet(fObservables) , intRange ) );
    }
  }
  
  RooAbsRealLValue* obs = dynamic_cast<RooAbsRealLValue*>(&fObservables[0]);
  
  //RooAbsBinning&
  const RooAbsBinning* obs_bins = obs->getBinningPtr(GetName());
  
  std::unique_ptr<TIterator> dnf(dependentNf.createIterator());
  std::unique_ptr<TIterator> dnfInt(dependentNfIntegrals.createIterator());
  
  double out(0.);
  for(int k=1;k<= (obs ? obs_bins->numBins() : 0);k++) {
    obs->setVal( obs_bins->binCenter(k-1) );
    if(!obs->inRange(rangeName)) continue;
    double binVal = getBinContent();
    obs->getBinning(intRange).setRange(obs_bins->binLow(k-1),obs_bins->binHigh(k-1));
    //divide out dependent normFactors
    dnf->Reset();dnfInt->Reset();
    while( (arg = (RooAbsReal*)dnf->Next()) ) {
      double oldVal = arg->getVal();
      double inte = ((RooAbsReal*)dnfInt->Next())->getVal();
      std::cout << arg->GetName() << " value in bin " << k << " obsVal=" << obs->getVal() <<" is " << oldVal << " integral = " << inte << std::endl;
      binVal /= arg->getVal();
      binVal *= inte;
      out += binVal;
    }
  }
  return out;

}

*/

//_____________________________________________________________________________
Double_t TRooH1::getValV(const RooArgSet* nset) const
{
  if(kUseAbsPdfValV) return RooAbsPdf::getValV(nset);
  ///THIS CODE IS COPIED FROM BUT SLIGHTLY MODIFIED VERSION OF RooAbsPdf::getValV
  ///DONE TO SUPPRESS WARNINGS ABOUT NEGATIVE VALUES
  
  // Return current value, normalizated by integrating over
  // the observables in 'nset'. If 'nset' is 0, the unnormalized value. 
  // is returned. All elements of 'nset' must be lvalues
  //
  // Unnormalized values are not cached
  // Doing so would be complicated as _norm->getVal() could
  // spoil the cache and interfere with returning the cached
  // return value. Since unnormalized calls are typically
  // done in integration calls, there is no performance hit.

  // Fast-track processing of clean-cache objects
  //   if (_operMode==AClean) {
  //     cout << "RooAbsPdf::getValV(" << this << "," << GetName() << ") CLEAN  value = " << _value << endl ;
  //     return _value ;
  //   }

  // Special handling of case without normalization set (used in numeric integration of pdfs)
  if (!nset) {
    RooArgSet* tmp = _normSet ;
    _normSet = 0 ;
    Double_t val = evaluate() ;
    _normSet = tmp ;
    Bool_t error = (TMath::IsNaN(val)) ? traceEvalPdf(val) : false; //allows negative and zero values

    if (error) {
//       raiseEvalError() ;
      return 0 ;
    }
    return val ;
  }


  // Process change in last data set used
  Bool_t nsetChanged(kFALSE) ;
  if (nset!=_normSet || _norm==0) {
    nsetChanged = syncNormalization(nset) ;
  }

  // Return value of object. Calculated if dirty, otherwise cached value is returned.
  if (isValueDirty() || nsetChanged || _norm->isValueDirty()) {

    // Evaluate numerator
    Double_t rawVal = evaluate() ;
    Bool_t error = (TMath::IsNaN(rawVal)) ? traceEvalPdf(rawVal) : false; //allows negative and zero values // Error checking and printing

    if(kMustBePositive && rawVal < fFloorValue) rawVal=fFloorValue;

    // Evaluate denominator
    Double_t normVal(_norm->getVal()) ;
    
    //add the missing bin, if its defined
    //if(fMissingBinProxy.absArg()) normVal += fMissingBinProxy;
    //if(fMissingBin) normVal += fMissingBin->getVal();
    
//     if (normVal<=0.) {
//       error=kTRUE ;
//       logEvalError("p.d.f normalization integral is zero or negative") ;  
//     }

    // Raise global error flag if problems occur
    if (error) {
//       raiseEvalError() ;
      _value = 0 ;
    } else {
      _value = rawVal / normVal ;
//       cout << "RooAbsPdf::getValV(" << GetName() << ") writing _value = " << rawVal << "/" << normVal << " = " << _value << endl ;
    }

    if(rawVal==0 && normVal==0) _value=1;
    

    clearValueAndShapeDirty() ; //setValueDirty(kFALSE) ;
  } 

  return _value ;
}




