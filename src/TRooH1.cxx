/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TRooFit/TRooH1.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "RooAbsLValue.h"
#include "RooRealVar.h"
#include "RooProdPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooProduct.h"
#include "RooAddition.h"
#include "RooConstVar.h"

#include "RooDataSet.h"
#include "RooDataHist.h"

#include "RooNumIntConfig.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"

#include "RooCachedReal.h"

#include "RooBinning.h"

#include "TRooFit/TRooHStack.h"

#include <memory>

#include "TGraphErrors.h"

ClassImp(TRooH1) 
ClassImp(TRooH0D) 


TRooH1::TRooH1(const char* name, const char* title) : TRooH1(name,title,RooArgList(),{},{},{}) {}
TRooH1::TRooH1(const char *name, const char *title,const RooArgList& observables, const int* bins, const double* min, const double* max ) : TRooH1(name,title,observables,bins,min,max,{},0) {}
TRooH1::TRooH1(const char *name, const char *title,const RooArgList& observables, std::vector<int>&& bins, std::vector<double>&& min, std::vector<double>&& max ) : 
  TRooH1(name,title,observables,&bins[0],&min[0],&max[0],{},0) {}
TRooH1::TRooH1(const char *name, const char *title, const RooArgList& observables, TH1* hist) :
    TRooH1(name,title,observables,0,0,0,{},hist) {}
TRooH1::TRooH1(const char *name, const char *title, 
                        const RooArgList& observables, std::vector<int>&& bins, std::vector<const Double_t*>&& binEdges ) : TRooH1(name,title,observables,&bins[0],0,0,std::move(binEdges),0) {}

TRooH1::TRooH1(const char *name, const char *title, const RooArgList& observables, const int* bins, const double* min, const double* max, std::vector<const Double_t*>&& binEdges, TH1* hist) :
   RooAbsPdf(name,title), TRooAbsH1(observables,this),
   fParameters("!pars","pars",this),
   fValues("!vals","!vals",this)
   
{ 
  //Only experts should construct TRooH1 directly. Please use derived classes (e.g. TRooH1D)

 
  //add binning to the continuous observables
  //also store the binnings and category sizes
  int j=0;
  for(int i=0;i<fObservables.getSize();i++) {
    if(fObservables[i].IsA() == RooRealVar::Class()) {
      if(hist) {
        if(hist->GetXaxis()->GetXbins()->GetArray()) {
          static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(hist->GetXaxis()->GetNbins(),hist->GetXaxis()->GetXbins()->GetArray()),name );
        } else {
          static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),hist->GetXaxis()->GetNbins()),name);
        }
      } else if(min==0) {
        static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(bins[j],binEdges[j]),name);
      } else {
        static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(min[j],max[j],bins[j]),name);
      }
      j++;
    } else if(fObservables[i].IsA() == RooCategory::Class()) {
      RooCategory& cat = static_cast<RooCategory&>(fObservables[i]);
      std::unique_ptr<TIterator> itr( cat.typeIterator() );
      RooCatType* tt = 0;
      while( (tt = (RooCatType*)itr->Next()) ) {
        cat.addToRange(GetName(),tt->GetName());
      }
    }
  }
  
//   //update axis in parent TH1
//   fNCells = 1;
//   switch(fObservables.getSize()) {
//     case 3: fZaxis.Set(bins[2],min[2],max[2]); fNCells *= (bins[2]+2);
//     case 2: fYaxis.Set(bins[1],min[1],max[1]); fNCells *= (bins[1]+2);
//     case 1: fXaxis.Set(bins[0],min[0],max[0]); fNCells *= (bins[0]+2);
//   }
//   fDimension=fObservables.getSize();
  
  if(hist) {
       //FIXME: should do checks on hist dimensions 
      fHists.push_back( (TH1*)hist->Clone(name) );
      fHists[0]->SetDirectory(0);fHists[0]->Reset(); //clears it 
      Add( hist ); //adds it, so that stat factors are created 
  } else {
  
    //create the default hist
    if(fObservables.getSize()==0) {
      fHists.push_back( new TH1D(name,title,1,-0.5,0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
    } else if(fObservables.getSize()==1) {
      if(fObservables[0].IsA() == RooCategory::Class()) { 
        RooCategory& cat = static_cast<RooCategory&>(fObservables[0]);
        fHists.push_back( new TH1D(name,title,cat.numTypes(),-0.5,cat.numTypes()-0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      } else {
        if(min==0) {
          fHists.push_back( new TH1D(name,title,bins[0],binEdges[0]) );
        } else {
          fHists.push_back( new TH1D(name,title,bins[0],min[0],max[0]) );
        }
        fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      }
      specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
    } else if(fObservables.getSize()==2) {
      if(min==0) {
        fHists.push_back( new TH2D(name,title,bins[0],binEdges[0],bins[1],binEdges[1]) );
      } else {
        fHists.push_back( new TH2D(name,title,bins[0],min[0],max[0],bins[1],min[1],max[1]) );
      }
      fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    } else {
      std::cout << "not supported!" << std::endl;
    }
  }
 
  fParameterSnapshots.resize(1); //creates an empty vector
  fDummyHist = fHists[0];fDummyHist->GetXaxis()->SetTitle("");fDummyHist->GetYaxis()->SetTitle("");
  setAttribute("NeverConstant",true); //stops these objects being 'cached' away, because they rarely should be
  RooMsgService::instance().getStream(RooFit::INFO).removeTopic(RooFit::NumIntegration); //stop info message every time
} 





TRooH1::TRooH1(const TRooH1& other, const char* name) :  
   RooAbsPdf(other,name), TRooAbsH1(other,this),
   fParameters(other.fParameters.GetName(),this,other.fParameters),
   fValues(other.fValues.GetName(),this,other.fValues),
   fHists(other.fHists),
   fFunctionalBinValues(other.fFunctionalBinValues),
   fParameterSnapshots(other.fParameterSnapshots),
   fTransFactor(other.fTransFactor),kIsTransNumerator(other.kIsTransNumerator),
   fInterpCode(other.fInterpCode),fObsInterpCode(other.fObsInterpCode)
{
  //Copy constructor
}



void TRooH1::isData(bool forceBinned) {
  //EXPERIMENTAL: do not use

  if(fData) { Warning("isData","Already configured for data"); return; }
  
  
  
  //we will combine observables with discrete parameters 
  //will also check we have no continuous parameters

  RooArgSet obsAndCat; obsAndCat.add(fObservables);
  
  RooFIter parItr(fParameters.fwdIterator());
  while(auto par = parItr.next() ) {
    if(par->InheritsFrom( RooAbsCategory::Class() )) {
      obsAndCat.add(*par);
    } else {
      //found a continuous parameter ... exit
      Error("isData","TRooH1 with continuous parameter %s cannot be made into data",par->GetName());
      return;
    }
  }
  
  bool doBinned = forceBinned;
  if(!doBinned) {
    //check if we have any entries in our hists ... if so we must do binned 
    for(auto& hist : fHists) {
      if(hist->GetEntries()>0) { 
        Warning("isData","Constructing binned data....");
        doBinned=true; break;
      }
    }
  }
  
  if(doBinned) {
    fData = new RooDataHist(Form("%s_data",GetName()),GetTitle(),obsAndCat,GetName()); //uses our binning for continuous observables 
    //FIXME: Add existing data
  } else {
    fDataWeightVar = new RooRealVar(Form("%s_weight",GetName()),Form("%s_weight",GetName()),1);
    obsAndCat.add(*fDataWeightVar);
    fData = new RooDataSet(Form("%s_data",GetName()),GetTitle(),obsAndCat,fDataWeightVar->GetName());
  }
  
}

 
TRooH1* TRooH1::createTransFactor( TRooH1* transferFrom ) {
  //A transFactor is ..

  if(fTransFactor) {
    Error("createTransFactor","%s: Transfer factor already exists",GetName());
    return fTransFactor;//static_cast<TRooH1*>(fTransFactor.absArg());
  }
  
  //FIXME add binning consistency checks between me and denominator etc etc
  
  TRooH1* transFactor = new TRooH1( Form("trans_%s_%s",GetName(),transferFrom->GetName()), "Transfer factor", fObservables, fHists[0] );
  
  kIsTransNumerator = true;
  fTransFactor = transFactor;
  addNormFactor( *transferFrom ); addNormFactor( *transFactor );
  
  transferFrom->fTransFactor = transFactor;//transferFrom->fTransFactor.SetName("transFactor");
  //NOTE: should we remove the fParameters from the denominator?
  
  //need to compute transfer factors from existing histograms
  //first copy over all the numerator hists and paramsets 
  transFactor->fParameters.add( fParameters ); 
  if(fParameters.getSize()) transFactor->fParameters.setName("pars"); 
  transFactor->fParameterSnapshots = fParameterSnapshots;
  //duplicate each histogram too, already did first one above
  for(uint i=1;i<fHists.size();i++) {
    transFactor->fHists.push_back( (TH1*)fHists[i]->Clone(GetName()) );
    transFactor->fHists.back()->SetDirectory(0);
  }
  
  
  
  //now go through and divide each hist by the corresponding hist in the denominator
  RooArgSet ss; fParameters.snapshot(ss); //save state of parameters 
  for(uint i=0;i<fParameterSnapshots.size();i++) {
    for(uint j=0;j<fParameterSnapshots[i].size();j++) {
      if(fParameters[j].InheritsFrom(RooAbsCategory::Class())) {
        (dynamic_cast<RooAbsCategoryLValue&>(fParameters[j])).setIndex(int(fParameterSnapshots[i][j]+0.5));
      } else {
        (dynamic_cast<RooAbsRealLValue&>(fParameters[j])).setVal(fParameterSnapshots[i][j]);
      }
    }
    //parameters aligned, now get the histogram 
    int pset = transferFrom->getParamSet();
    if(pset==-1) {
      Error("createTransFactor","Failed to get denominator histogram");
    } else {
      //TH1* h0 = transFactor->fHists[i]; don't use h0 directly, use SetBinContent method so that can propagate to further transFactors
      TH1* h1 = fHists[i];
      TH1* h2 = transferFrom->GetHist(pset);
      int nbinsz = (h1->GetDimension()<3) ? -1 : h1->GetNbinsZ();
      int nbinsy = (h1->GetDimension()<2) ? -1 : h1->GetNbinsY();
      int nbinsx = h1->GetNbinsX();
      //follow convention that if two bins are both 0, then the transfer factor is actually 1!
      double b1,b2;
      for(int binz=0;binz<=nbinsz+1;binz++) {
        for(int biny=0;biny<=nbinsy+1;biny++) {
          for(int binx=0;binx<=nbinsx+1;binx++) {
            int bin=binx+(nbinsx+2)*(biny + (nbinsy+2)*binz);
            b1 = h1->GetBinContent(bin);b2 = h2->GetBinContent(bin);
            if(b2==0 && b1==0) transFactor->SetBinContent(bin,1);
            else if(b2==0) {
              Warning("createTransferFactor","denominator zero in bin %d ... setting transFactor to 0",bin);
              transFactor->SetBinContent(bin,0);
            } else transFactor->SetBinContent( bin, b1/b2 );
          }
        }
      }
    }
  }
  fParameters = ss; //resets parameter values
  
  
  return transFactor;
}

bool TRooH1::addParameter( RooAbsArg& arg , int interpCode ) { 
  //Use this method to turn this TRooFit histogram into a function of the given parameter, arg.
  //All the previously filled values of the histogram will be assumed to correspond 
  //to the current value of the parameter 
  //
  //You can then change the value of the parameter and start to re-fill the histogram 
  //This will then make the histogram correspond to a coherent variation. 
  //
  //The interpCode determines the interpolation between parameter points .
  //See TRooH1::setInterpCode for description of different options.
  //Default interpCode (0) is piecewise linear interpolation
  //

  if(fParameters.find(arg)) return false; //already added
  if(fData) {
    if(!arg.InheritsFrom(RooAbsCategory::Class())) {
      Error("addParameter","Can only add category parameters to data");
      return false;
    }
    if(fData->InheritsFrom(RooDataSet::Class())) {
      ((RooDataSet*)fData)->addColumn(arg);
    } else {
      //FIXME: add observable for RooDataHist!?
    }
  }
  
  
  fParameters.add(arg); fParameters.setName("pars"); fInterpCode.push_back(interpCode);
  if(fMissingBin) fMissingBin->addParameter(arg, interpCode);
  //add a clone to all existing paramsets too
  double val = (arg.InheritsFrom(RooAbsCategory::Class())) ? static_cast<RooAbsCategory&>(arg).getIndex() : static_cast<RooAbsReal&>(arg).getVal();
  for(auto& pars : fParameterSnapshots) {
    pars.push_back(val);
  }
  
  //need to also tell all clients that we have a new parameter to depend on
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->addServer(arg);client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}





Bool_t TRooH1::Add(const TH1* h1 , Double_t c1) {
  //Add a histogram to this TRooH1, i.e. fill the content of h1 into this TRooH1
  //includes the optional scaling factor c1

  int pset = getOrCreateParamSet();
  bool out = fHists[pset]->Add(h1,c1);
  
  if(out && pset==0) { //add succeeded, and was adding to 'nominal' set, so adjust stat factors
    for(int i=1;i<=h1->GetNbinsX();i++) {
      for(int j=1;j<=h1->GetNbinsY();j++) {
        for(int k=1;k<=h1->GetNbinsZ();k++) {
          int bin = h1->GetBin(i,j,k);
          if(!h1->GetBinError(bin)) continue; //don't need to adjust if there was no error
          RooRealVar* statFactor = getStatFactor(bin); //first try without creating 
          if(!statFactor) { 
            statFactor = getStatFactor(bin, true);  //automatically sets sumw and sumw2 for us when creating a new statFactor
          } else {
            //update the sumw and sumw2 attribute of the stat factor
            statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() + h1->GetBinContent(bin)*c1)));
            statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() + pow(h1->GetBinError(bin)*c1,2))));
            //will also set the error to sqrt(sumw2)/sumw
            statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
            if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
          }
        }
      }
    }
  }
  return out;
}


Int_t TRooH1::Fill( double x , double w ) {
  //The usual histogram Fill method
  //This method will trigger the automatic creation of parameters (as necessary) 
  // to represent the statistical uncertainty in the filled bin 

  int pset = getOrCreateParamSet();
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { w = x; x = 0; } //in the counting-mode, the x variable is always "0"
  
  //only create stat factors when filling the 'nominal' histogram
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin, true);
    //update the sumw and sumw2 attribute of the stat factor
    statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() + w)));
    statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() + w*w)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    
  }
  
  //temporarily move the relevent observable onto our value
  if(fData) {
    RooArgSet obsAndPars; obsAndPars.add(fObservables); obsAndPars.add(fParameters);
    if(fDataWeightVar) fDataWeightVar->setVal(w);
    if(fObservables.getSize()) {
      if(fObservables[0].InheritsFrom(RooCategory::Class())) {
        RooCategory& c = dynamic_cast<RooCategory&>(fObservables[0]);
        int tmpIdx = c.getIndex();
        c.setIndex(x);
        fData->add( obsAndPars , w );
        c.setIndex(tmpIdx);
      } else {
        RooAbsRealLValue& v = dynamic_cast<RooAbsRealLValue&>(fObservables[0]);
        double tmpVal = v.getVal();
        v.setVal(x);
        fData->add( obsAndPars , w );
        v.setVal(tmpVal);
      }
    } else {
      //0D case ... just fill!
      fData->add( obsAndPars , w );
    }
  }
  
  
  return fHists[pset]->Fill(x,w);
  
  //FIXME: propagate changes to transFactor if there is one!
  
}

Int_t TRooH1::Fill( const char* name , double w ) {
  //Same as above, but can use name of Category type
  
  if(GetDimension()==0) return Fill(0.,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("Fill","%s is not a category, cannot fill",fObservables[0].GetName());
    return -1;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("Fill","%s unknown label in %s",name,fObservables[0].GetName());
    return -1;
  }
  return Fill( type->getVal() , w );
  
}

  
Int_t TRooH1::Fill( Double_t x, RooAbsReal& val ) {
  //Fills (i.e. adds) a function to bin at x value, 
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { bin = -1; } 
  
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return fValues.index(&val);
  
}


Int_t TRooH1::Fill( RooAbsReal& val ) {
  //fill every bin with this function
  
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
    
  fFunctionalBinValues[-1].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return 0;
  
}

void TRooH1::FillMissing(double w) {
  //Fill (i.e. adds to) the content of the 'missing events' bin 
  
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->Fill(w);
}



Int_t TRooH1::getOrCreateParamSet() {
  //Internal method used when updating the content of the TRooH1
  //e.g. in SetBinContent, Fill, SetBinError, etc

  setValueDirty();
  //we have to dirty up ALL clients, not just those who have said they are value clients
  //integrals don't think of themselves as value clients because they think they integrate out changes in our value
  //i.e. they assume the only way a function can change value is if the servers change values
  //and so the only way THEY can change value is if the non-integrated servers change value
  
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  

  int pset = getParamSet();
  
  if(pset==-1) { //need to create a new hist, clone the "nominal" hist
    std::vector<double> parVals;
    //get the current paramter values
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      if(par->InheritsFrom( RooAbsCategory::Class() )) {
        parVals.push_back( ((RooAbsCategory*)par)->getIndex() );
      } else {
        parVals.push_back( ((RooAbsReal*)par)->getVal() );
      }
    }
    fParameterSnapshots.push_back(parVals);
    fHists.push_back( (TH1*)fHists[0]->Clone( Form("%s_variation%d",GetName(),int(fParameterSnapshots.size()))) ); 
    fHists.back()->SetDirectory(0);
    fHists.back()->Reset();
    pset = fParameterSnapshots.size()-1;
    
    
  }
  return pset;
}

bool TRooH1::setInterpCode(const char* parName, int code) {
  //Set interpolation code for a given parameter or observable
  //
  //Observables:
  // 0 = binned (default behaviour) 
  // 1 = linear interpolation between each bin 
  //
  //Parameters:
  // 0 = piecewise linear 
  // 2 = 6th order polynominal with log extrapolation (should match code 4, but this implemented differently)
  // 3 = 6th order polynominal with linear extrapolation (Like HistFactory::PiecewiseInterpolation's code 4)
  // 4 = 6th order polynominal with log extrapolation (Like HistFactory::FlexibleInterpVar's code 4)
  //
  //Note that in all cases, if only one variation (parameter space point) is provided for the given parameter
  //then straightforward linear interpolation is used. 
  //
  //Returns true on success


  int idx = fParameters.index(parName);
  if(idx==-1) {
    //check observables 
    idx = fObservables.index(parName);
    if(idx==-1) return false;
    if(code==0 && (fObsInterpCode&(1<<idx))) fObsInterpCode -= (1<<idx);
    else if( (fObsInterpCode&(1<<idx)) ==0) fObsInterpCode += (1<<idx);
  } else {
    fInterpCode[idx] = code;
  }
  
  //make everything dirty
  setValueDirty();
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}

bool TRooH1::setInterpCode(const RooAbsArg& arg, int code) {
  //Same as above, but can pass the actual argument 
  //
  return setInterpCode(arg.GetName(),code);
}


void TRooH1::SetBinContent( int bin, double val ) {
  //Set the contents of a given bin

  int pset = getOrCreateParamSet();
  //update the statFactor's sumw, if necessary
  if(pset==0 && fHists[pset]->GetBinContent(bin)) {
    RooRealVar* statFactor = getStatFactor(bin);
    if(statFactor) {
      statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() - fHists[pset]->GetBinContent(bin) + val)));
      //will also set the error to sqrt(sumw2)/sumw
      statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
      if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    }
  }
  fHists[pset]->SetBinContent(bin,val);
  //FIXME: propagate changes to transFactor if there is one!
}

void TRooH1::SetBinContent( const char* name , double w ) {
  //Set the contents of a given bin 
  //The first observable of this TRooH1 must be a RooCategory

  //first observable must be a category
  if(GetDimension()==0) SetBinContent(1,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("SetBinContent","%s is not a category, cannot fill",fObservables[0].GetName());
    return;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("SetBinContent","%s unknown label in %s",name,fObservables[0].GetName());
    return;
  }
  SetBinContent( type->getVal() + 1 , w );
  
}

void TRooH1::SetBinContent( int bin, RooAbsReal& val ) {
  //Sets the bin content equal to a function value 
  
  SetBinContent(bin,0.); //clears existing content 
  
  if(fValues.index(&val)==-1) fValues.add(val);
  if(fObservables.getSize()==0) { bin = -1; } 
  
  fFunctionalBinValues[bin].clear(); //removes existing values 
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  
}

void TRooH1::SetMissingContent(double w) {
  //Set the content of the 'missing events' bin
  //This is held in a separate 0-bin TRooH1 (i.e. a TRooH0D)
  
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->SetBinContent(1,w);
}


void TRooH1::SetBinError( int bin, double error ) {
  //Set the error of the given bin
  //If a statFactor for the bin does not already exist, it will be created

  int pset = getOrCreateParamSet();
  
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin,true);
    //update the sumw2 attribute of the stat factor ... 
    //the factor might be shared if its in a stack, so must subtract old error and add new one
    statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() - pow(fHists[pset]->GetBinError(bin),2) + error*error)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
  } else {
    Warning("SetBinError","Bin errors only used when in nominal histogram");
  }
  
  fHists[pset]->SetBinError(bin,error);
  
}

void TRooH1::SetMissingError(double w) {
  //Set the error of the 'missing events' bin 
  //If a statFactor for the bin does not already exist, it will be created 
  
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->SetBinError(1,w);
}





Int_t TRooH1::getParamSet() const {
  //Returns the ID of the current parameter spacepoint 
  //Or if the state of the parameters is an unknown point
  //then this method will return -1.

  if(fParameters.getSize()==0) return 0;
  
  //compare parameter values up to a certain 'precision' for equality
  int i=0;
  for(auto& parVals : fParameterSnapshots) {
    bool match(true);
    
    uint j=0;
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
      double val = 0;
      if(cat) {
        val = cat->getIndex();
      } else {
        val = static_cast<RooAbsReal*>(par)->getVal();
      }
      if( fabs(val - parVals[j]) > 1e-9 ) {match=false;break;}
      j++;
    }
    if(match) return i;
    i++;
  }
  
  return -1;
}


const std::vector<double>& TRooH1::GetParamSet(int idx) const { 
  //Return the values of the parameters corresponding to paramSet = idx
  //The order of the parameters can be seen through the Print method 
  
  return fParameterSnapshots[idx]; 
}

Double_t TRooH1::evaluate() const 
{
  //The main roofit evaluation method. Users should not call this directly 
  //It is computing the pdf value (the probability density) 

//std::cout << "rangeName = " << GetRangeName() << " "; fObservables.Print("v"); 

  double out = 0;
  int bin = getBin(GetName()); //forcefully use OUR binning 

  //if using transfer factors
  if(fTransFactor && kIsTransNumerator) {
    //numerator will just have value = TransferFactor*Denominator
    //these were both added as NormFactors in createTransFactor
    out = 1;
  
  } else {

    //loop over parameter snapshots, assessing which sets are valid (discrete params must match exactly)
    //if we find an exact match, we go with that
    
    //goal is that for each parameter to obtain the spacepoint IDs for the two closest valid spacepoints
    
    std::vector<int> upSet(fParameters.getSize(),-1); 
    std::vector<int> downSet(fParameters.getSize(),-1); 
    int nomSet = -1;
    
    int pset=-1;
    if(fParameters.getSize()==0 || (fTransFactor && !kIsTransNumerator)) { //always use nominal if we are the denominator
      pset=0;
    } else {
    
      int i=0;
      std::vector<int> setUp;std::vector<int> setDown; //get filled with parameter indices that should get set to up/down
      for(auto& parVals : fParameterSnapshots) {
        bool match(true); bool invalid(false);
        RooFIter parItr(fParameters.fwdIterator());
        int j=0; 
        setUp.clear();setDown.clear();
        while(auto par = parItr.next() ) {
          RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
          if(cat) {
            if( cat->getIndex() != int(parVals[j]+0.5) ) {
              match=false;invalid=true;break;
            }
          } else {
            //record if this is up/down/nom variation for this parameter
            double parVal = ((RooAbsReal*)par)->getVal();
            double parDiff = fabs(parVal - parVals[j]);
            if(parDiff > 1e-9) {
              match=false;
              if(nomSet==-1 && fInterpCode[j]!=0) continue; //don't use the nomSet as our up-vs-down set if interpCode!=0
            
              if(upSet[j]==-1) setUp.push_back(j); //if valid, will
              else if(downSet[j]==-1) setDown.push_back(j);
              else {
                //replace the one that is further away 
                double upDiff = fabs(fParameterSnapshots[upSet[j]][j] - parVal);
                double downDiff = fabs(fParameterSnapshots[downSet[j]][j] - parVal);
                if(parDiff<upDiff || parDiff<downDiff) {
                  if(upDiff>downDiff) setUp.push_back(j);
                  else setDown.push_back(j);
                }
              }
            }
          }
          j++;
        }
        if(match) {
          pset=i; 
          break; //can just stop right now, found a perfect match
        }
        if(!invalid) { //if snapshot featured a variation up or down, store that
          if(nomSet==-1) nomSet=i; //the first valid set is used as the nom set
          //signal which parameters this snapshot is a valid variation for
          for(auto& j : setUp) upSet[j]=i;
          for(auto& j : setDown) downSet[j]=i;
        }
        i++;
      }
    }
    
    //add the functional bin values
    double binVol = 1.;
    if(fFunctionalBinValues.find(-1)!=fFunctionalBinValues.end()) {
      
      int bb[3]; fDummyHist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
      for(int i=0;i<fDummyHist->GetDimension();i++) {
        TAxis* ax = 0; if(i==0) ax = fDummyHist->GetXaxis(); else if(i==1) ax = fDummyHist->GetYaxis(); //FIXME: assumes 2D at most
        binVol /= ax->GetBinWidth(bb[i]);
      }
      for(auto& vals : fFunctionalBinValues.at(-1)) {
        //warning: dont want to use getVal(_normSet) because we've added a pdf, not necessarily added a NORMALIZED pdf
        out += static_cast<RooAbsReal&>(fValues[vals]).getVal() * ( (fValues[vals].InheritsFrom(RooAbsPdf::Class())) ? 1. : binVol); //if function is a pdf, we assume it is already a density!
      }
    }
    if(fFunctionalBinValues.find(bin) != fFunctionalBinValues.end()) {
      if(binVol==1.) {
        int bb[3]; fDummyHist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        for(int i=0;i<fDummyHist->GetDimension();i++) {
          TAxis* ax = 0; if(i==0) ax = fDummyHist->GetXaxis(); else if(i==1) ax = fDummyHist->GetYaxis(); //FIXME: assumes 2D at most
          binVol /= ax->GetBinWidth(bb[i]);
        }
      }
      for(auto& vals : fFunctionalBinValues.at(bin)) {
        out += static_cast<RooAbsReal&>(fValues[vals]).getVal() * ( (fValues[vals].InheritsFrom(RooAbsPdf::Class())) ? 1. : binVol); //should we divide these by bin volume!!?? perhaps only if is function of observables
      }
    }
    

    if(pset!=-1) {
      //add the raw values too
      TH1* hist = GetHist(pset);
      
      //calculate bin volume, only if necessary though .. 
      double val(0);
      if(fObsInterpCode) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        switch(hist->GetDimension()) {
          case 1: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] )); break;
          case 2: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ) ); break;
          case 3: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ),
                                     (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hist->GetYaxis()->GetBinCenter( bb[2] ) ); break;
        }
      } else {
         val = hist->GetBinContent(bin);
      }
      if(val) {
        if(binVol==1.) {
          int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
          for(int i=0;i<hist->GetDimension();i++) {
            TAxis* ax = 0; if(i==0) ax = hist->GetXaxis(); else if(i==1) ax = hist->GetYaxis(); //FIXME: assumes 2D at most
            binVol /= ax->GetBinWidth(bb[i]);
          }
        }
        val *= binVol;
      }
      
      out += val;
    } else if(nomSet!=-1) { //can only interpolate when there's a valid parameter spacepoint
      //got here, must interpolate
      //loop over parameters, and use upSet and downSet to compute interpolated result
      TH1* hist = GetHist(nomSet);
      double nomVal(0);
      if(fObsInterpCode) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        switch(hist->GetDimension()) {
          case 1: nomVal = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] )); break;
          case 2: nomVal = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ) ); break;
          case 3: nomVal = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ),
                                     (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hist->GetYaxis()->GetBinCenter( bb[2] ) ); break;
        }
      } else {
        nomVal = hist->GetBinContent(bin);
      }
      double val = nomVal;

      RooFIter parItr(fParameters.fwdIterator());
      int i=-1;
      while(auto par = parItr.next() ) {
        i++;
        if(par->InheritsFrom( RooAbsCategory::Class() ) ) continue;
        if(upSet[i]==-1) continue; //no variation for this parameter (need at least a point)
        
        //now calculate the value based on interpolation between these two points 
        double y_up(0);
        double y_down(nomVal);
        if(fObsInterpCode) {
          TH1* hh = GetHist( upSet[i] );
          int bb[3]; hh->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
          switch(hh->GetDimension()) {
            case 1: y_up = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] )); break;
            case 2: y_up = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                      (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ) ); break;
            case 3: y_up = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                      (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ),
                                      (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hh->GetYaxis()->GetBinCenter( bb[2] ) ); break;
          }
          if(downSet[i]!=-1) {
            hh = GetHist( downSet[i] );
            switch(hh->GetDimension()) {
              case 1: y_down = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] )); break;
              case 2: y_down = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                        (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ) ); break;
              case 3: y_down = hh->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hh->GetXaxis()->GetBinCenter( bb[0] ), 
                                        (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hh->GetYaxis()->GetBinCenter( bb[1] ),
                                        (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hh->GetYaxis()->GetBinCenter( bb[2] ) ); break;
            }
          }
          
        } else {
          y_up = GetHist( upSet[i] )->GetBinContent(bin);
          if(downSet[i]!=-1) y_down = GetHist( downSet[i] )->GetBinContent(bin);
        }
        double x_up = fParameterSnapshots[upSet[i]][i];
        double x_val = ((RooAbsReal*)par)->getVal();
        
        
        bool doCode2(false);
        switch(fInterpCode[i]*(downSet[i]!=-1)) {
        case 0:{ //piecewise linear always used if only one variation
             //if downSet unavailable, use nominal set as the down variation
            double x_down = (downSet[i]==-1) ? fParameterSnapshots[nomSet][i] : fParameterSnapshots[downSet[i]][i];
            double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
            val += (tmpVal - nomVal);
            }break;
        case 2: //6th order poly with log extrapolation 
            doCode2=true;
        case 3:{ //6th order poly with linear extrapolation
            double x_down = fParameterSnapshots[downSet[i]][i];
            
            if(x_val < x_down && x_val < x_up) {
              if(doCode2) {
                val *= (x_down < x_up) ? std::pow(y_down/nomVal, x_val/x_down) : std::pow(y_up/nomVal, x_val/x_up);
              } else {
                //linear extrapolate from x_val and x_down or x_up, whichever is lower 
                if(x_down < x_up) {
                  y_up = nomVal; x_up = fParameterSnapshots[nomSet][i];
                } else {
                  y_down = nomVal; x_down = fParameterSnapshots[nomSet][i];
                }
                double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
                val += (tmpVal - nomVal);
              }
            } else if(x_val > x_up && x_val > x_down) {
              if(doCode2) {
                val *= (x_down < x_up) ? std::pow(y_up/nomVal, x_val/x_up) : std::pow(y_down/nomVal, x_val/x_down);
              } else {
                //linear extrapolate from x_val and x_down or x_up, whichever is lower 
                if(x_down < x_up) {
                  y_down = nomVal; x_down = fParameterSnapshots[nomSet][i];
                } else {
                  y_up = nomVal; x_up = fParameterSnapshots[nomSet][i];
                }
                double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
                val += (tmpVal - nomVal);
              }
            } else {
              //Code based off what is in HistFactor::PiecewiseInterpolation (interpCode 4)
            
              //scale and shift x values so x_up-x_down = 2 and x_up+x_down=0 (i.e. usual +1, -1 case) 
              //sf even flips x_up and x_down so that x_up > x_down
              //std::cout << "x_val =" << x_val << " x_up=" << x_up << " x_down=" << x_down << std::endl;
              double sf = 2.0/(x_up-x_down);
              x_val *= sf; x_up *= sf; x_down *= sf;
              double sh = (x_up+x_down)/2.0;
              x_val -= sh; 
              double eps_plus = y_up-nomVal; double eps_minus=nomVal-y_down;
              double S = 0.5 * (eps_plus + eps_minus);
              double A = 0.0625 * (eps_plus - eps_minus);
              val += x_val * (S + x_val * A * ( 15 + x_val * x_val * (-10 + x_val * x_val * 3  ) ) );
            }
                    
            }break;
        case 4:{ //6th order polynomial with log extrapolation
            double x_down = fParameterSnapshots[downSet[i]][i];
        
        
            //scale and shift x values so x_up-x_down = 2 and x_up+x_down=0 (i.e. usual +1, -1 case) 
            //sf even flips x_up and x_down so that x_up > x_down
            
            //std::cout << "x_val =" << x_val << " x_up=" << x_up << " x_down=" << x_down << std::endl;
            double sf = 2.0/(x_up-x_down);
            x_val *= sf; x_up *= sf; x_down *= sf;
            double sh = (x_up+x_down)/2.0;
            x_val -= sh; //x_up -= sh; x_down -= sh; //... x_up and x_down should equal 1 and -1 by this point
            
        
            if(x_val >= 1.) {
              val *= std::pow(y_up/nomVal, x_val);
            } else if(x_val <= -1.) {
              val *= std::pow(y_down/nomVal, -x_val);
            } else if(x_val) {
              //Based off what is in FlexibleInterpVar (interpCode 4)
              
              //coefficients can be precomputed, but are function of nomSet, upSet, downSet indices, bin, and i
              
              double coeff[6];
              
              double pow_up       =  y_up/nomVal;
              double pow_down     =  y_down/nomVal;
              double logHi        =  std::log(pow_up) ; //BUGFIXED!
              double logLo        =  std::log(pow_down); //BUGFIXED!
              double pow_up_log   = y_up <= 0.0 ? 0.0 : pow_up * logHi;
              double pow_down_log = y_down <= 0.0 ? 0.0 : -pow_down    * logLo;
              double pow_up_log2  = y_up <= 0.0 ? 0.0 : pow_up_log  * logHi;
              double pow_down_log2= y_down <= 0.0 ? 0.0 : -pow_down_log* logLo;
      
              double S0 = (pow_up+pow_down)/2;
              double A0 = (pow_up-pow_down)/2;
              double S1 = (pow_up_log+pow_down_log)/2;
              double A1 = (pow_up_log-pow_down_log)/2;
              double S2 = (pow_up_log2+pow_down_log2)/2;
              double A2 = (pow_up_log2-pow_down_log2)/2;
              
              //fcns+der+2nd_der are eq at bd
              
              // cache  coefficient of the polynomial 
              coeff[0] = 1./(8)        *(      15*A0 -  7*S1 + A2);
              coeff[1] = 1./(8)     *(-24 + 24*S0 -  9*A1 + S2);
              coeff[2] = 1./(4)*(    -  5*A0 +  5*S1 - A2);
              coeff[3] = 1./(4)*( 12 - 12*S0 +  7*A1 - S2);
              coeff[4] = 1./(8)*(    +  3*A0 -  3*S1 + A2);
              coeff[5] = 1./(8)*( -8 +  8*S0 -  5*A1 + S2);
              
              
              val *= (1. + x_val * (coeff[0] + x_val * (coeff[1] + x_val * (coeff[2] + x_val * (coeff[3] + x_val * (coeff[4] + x_val * coeff[5]) ) ) ) ) );
              
            }
            
            
            }break;
        }

        
      }
      
      if(val) { //divide by bin volume if it's necessary to
        if(binVol==1.) {
          int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
          for(int i=0;i<hist->GetDimension();i++) {
            TAxis* ax = 0; if(i==0) ax = hist->GetXaxis(); else if(i==1) ax = hist->GetYaxis(); //FIXME: assumes 2D at most
            binVol /= ax->GetBinWidth(bb[i]);
          }
        }
        val *= binVol; //binVol is already inverted
      }
      
      out += val;
    }
  }

  
  //multiply by all the norm factors
  RooFIter itr(fNormFactors.fwdIterator());
  while( RooAbsReal* arg = (RooAbsReal*)itr.next() ) out *= arg->getVal(); //NOTE: should we use _normSet? leads to issues if normfactor is a pdf...
  
  //and by the shape factors for this bin
  if(fBinsShapeFactors.find(bin)!=fBinsShapeFactors.end()) {
    for(auto& sfIdx : fBinsShapeFactors.at(bin)) {
      out *= ((RooAbsReal&)fShapeFactors[sfIdx]).getVal();
    }
  }
  
  return out;
  
}


Double_t TRooH1::expectedEvents(const RooArgSet* nset) const { 
  //Effectively corresponds to the integral of the TRooH1 over the 
  //observables provided in nset. 
  //
  //If you want the error on the integral, you should instead 
  //create a RooFit function that represents the integral 
  //You can do this with RooAbsReal::createIntegral
  //
  //If you want the integral to include the 'missing events' total 
  //you should use TRooAbsH1::createIntegralWM , which will return a 
  //RooAddition containing the missing event totals
  //
  //Once you have this RooFit function, you can propgate errors the usual way
  //using getPropagatedError

 if(nset==0/* || !dependsOn(*nset)*/) {
  //std::cout << " expected event 0 = " << getBinContent() << std::endl; 
  //return getBinContent(); //use the raw value for expected events
  return 1; //return 1 so that getBinContent is not messed up
 }
 double out = getNorm(nset);
 //std::cout << "expected events = " << out << std::endl;
 return out;
}



//these functions are needed by the RooBinIntegrator
std::list<Double_t>* TRooH1::binBoundaries(RooAbsRealLValue& obs, Double_t xlow, Double_t xhi) const {

  auto binning = obs.getBinningPtr(GetName()); //always use our own binning when integrating!
  std::list<Double_t>* out = new std::list<Double_t>;
  
  for(int i=0;i<binning->numBins();i++) {
    double binEdgeLow = binning->binLow(i);
    double binEdgeHigh = binning->binHigh(i);
    
    //if any overlap then we include
    if(binEdgeLow > xhi) break; //finished
    
    if(binEdgeHigh > xlow) {
      if(out->size()==0) out->push_back(binEdgeLow);
      out->push_back(binEdgeHigh);
    }
    
  }
  return out;
}

Bool_t TRooH1::isBinnedDistribution(const RooArgSet& obs) const {
  //if all obs are in the fObservables, then we are binnined
  RooFIter itr = obs.fwdIterator();
  while( RooAbsArg* arg = itr.next() ) {
    if(!fObservables.find(*arg)) return kFALSE;
  }
  return kTRUE;
}



//_____________________________________________________________________________
Bool_t TRooH1::syncNormalization(const RooArgSet* nset, Bool_t adjustProxies) const
{
  using namespace std;
  // Verify that the normalization integral cached with this PDF
  // is valid for given set of normalization observables
  //
  // If not, the cached normalization integral (if any) is deleted
  // and a new integral is constructed for use with 'nset'
  // Elements in 'nset' can be discrete and real, but must be lvalues
  //
  // For functions that declare to be self-normalized by overloading the
  // selfNormalized() function, a unit normalization is always constructed


//   cout << IsA()->GetName() << "::syncNormalization(" << GetName() << ") nset = " << nset << " = " << (nset?*nset:RooArgSet()) << endl ;

  _normSet = (RooArgSet*) nset ;
  //std::cout << "incoming = " << nset << std::endl;
  // Check if data sets are identical
  
  //for(int i=0; i < _normMgr._nsetCache.size();i++) {
  //  std::cout << "0cache nset (" << i << ") size=" << _normMgr._nsetCache[i].entries() << " index=" << _normMgr._nsetCache[i].index(nset,0,0) << std::endl;
  //}
  
  _normMgr._owner = 0; //dirty hack to stop autoCache method calling getObservables on me
  CacheElem* cache = (CacheElem*) _normMgr.getObj(nset) ;
  _normMgr._owner = (TRooH1*)this; //dirty hack to stop autoCache method calling getObservables on me
  
  
  //for(int i=0; i < _normMgr._nsetCache.size();i++) {
  //  std::cout << "cache nset (" << i << ") size=" << _normMgr._nsetCache[i].entries() << " index=" << _normMgr._nsetCache[i].index(nset,0,0) << std::endl;
  //}
  
  if (cache) {
    //check that variables integrated over matches
    //std::cout << "got cache " << cache->_norm->GetName() << " for (" << nset << ") : "; nset->Print();
    //std::cout << "value = " << cache->_norm->getVal() << std::endl;
    Bool_t nsetChanged = (_norm!=cache->_norm) ;
    _norm = cache->_norm ;


//      cout << "returning existing object " << _norm->GetName() << endl ;

    if (nsetChanged && adjustProxies) {
      // Update dataset pointers of proxies
      ((TRooH1*) this)->setProxyNormSet(nset) ;
    }
  
    return nsetChanged ;
  }
    
  // Update dataset pointers of proxies
  if (adjustProxies) {
    ((TRooH1*) this)->setProxyNormSet(nset) ;
  }
  
  //NOTE: an alternative to this 'depend on all observables' approach (where to auto extend uniformly in unknown observables)
  //would be to modify the unit normalization return below to be replaced by SELF VALUE
  //could use a RooFormulaVar for this, I guess, or a RooAddition with just ourself in the func list
  
  RooArgSet* depList = getObservables(nset); //(nset) ? new RooArgSet(*nset) : new RooArgSet;//WB integrate over all variables!! getObservables(nset) ;
  //depList->Print();

  if (_verboseEval>0) {
    if (!selfNormalized()) {
      cxcoutD(Tracing) << IsA()->GetName() << "::syncNormalization(" << GetName() 
	   << ") recreating normalization integral " << endl ;
      if (depList) depList->printStream(ccoutD(Tracing),kName|kValue|kArgs,kSingleLine) ; else ccoutD(Tracing) << "<none>" << endl ;
    } else {
      cxcoutD(Tracing) << IsA()->GetName() << "::syncNormalization(" << GetName() << ") selfNormalized, creating unit norm" << endl;
    }
  }

  // Destroy old normalization & create new
  if (selfNormalized()/* || !dependsOn(*depList)*/) {    
    TString ntitle(GetTitle()) ; ntitle.Append(" Unit Normalization") ;
    TString nname(GetName()) ; nname.Append("_UnitNorm") ;
    _norm = new RooRealVar(nname.Data(),ntitle.Data(),1) ;
  } else {    
    const char* nr = (_normRangeOverride.Length()>0 ? _normRangeOverride.Data() : (_normRange.Length()>0 ? _normRange.Data() : 0)) ;

//     cout << "RooAbsPdf::syncNormalization(" << GetName() << ") rangeName for normalization is " << (nr?nr:"<null>") << endl ;
    RooAbsReal* normInt = createIntegral(*depList,*getIntegratorConfig(),nr) ;
    normInt->getVal() ;
//     cout << "resulting normInt = " << normInt->GetName() << endl ;

    const char* cacheParamsStr = getStringAttribute("CACHEPARAMINT") ;
    if (cacheParamsStr && strlen(cacheParamsStr)) {
      
      RooArgSet* intParams = normInt->getVariables() ;
      
      RooNameSet cacheParamNames ;
      cacheParamNames.setNameList(cacheParamsStr) ;
      RooArgSet* cacheParams = cacheParamNames.select(*intParams) ;
      
      if (cacheParams->getSize()>0) {
	cxcoutD(Caching) << "RooAbsReal::createIntObj(" << GetName() << ") INFO: constructing " << cacheParams->getSize()
			 << "-dim value cache for integral over " << *depList << " as a function of " << *cacheParams << " in range " << (nr?nr:"<default>") <<  endl ;
	string name = Form("%s_CACHE_[%s]",normInt->GetName(),cacheParams->contentsString().c_str()) ;
	RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,*cacheParams) ;
	cachedIntegral->setInterpolationOrder(2) ;
	cachedIntegral->addOwnedComponents(*normInt) ;
	cachedIntegral->setCacheSource(kTRUE) ;
	if (normInt->operMode()==ADirty) {
	  cachedIntegral->setOperMode(ADirty) ;
	}
	normInt= cachedIntegral ;
      }
      
      delete cacheParams ;
      delete intParams ;
    }
    _norm = normInt ;    
  }
  
  // Register new normalization with manager (takes ownership)
  cache = new CacheElem(*_norm) ;
  _normMgr._owner = 0; //dirty hack to stop autoCache method calling getObservables on me
  _normMgr.setObj(nset,cache) ;
  _normMgr._owner = (TRooH1*)this; //dirty hack to stop autoCache method calling getObservables on me
  
//   cout << "making new object " << _norm->GetName() << endl ;

  delete depList ;
  return kTRUE ;
}

/*
Int_t TRooH1::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName) const {
  //for now, only worry about NormFactor depending on an observable that we are integrating on
  
  //we must end up copying to analVars the observables that a norm factor also depends on
  //for now we will do just 1D case
  
  auto integratingObs = fObservables.selectCommon(allVars);
  if(integratingObs->getSize()==0) { delete integratingObs; return 0; }
  RooFIter nf = fNormFactors.fwdIterator();
  RooAbsArg* arg; bool found(false);
  while( (arg = nf.next()) ) {
    if(arg->dependsOn(*integratingObs)) {
      found=true; //for now, if not found then fallback on integrator
      std::cout << " found= " << arg->GetName() << std::endl;
      analVars.add(*integratingObs); break; //for now just stop immediately ... could in future use the return code to say which normfactor is dependent
    }
  }
  
  
  delete integratingObs; return found;
  
  //note that if no factors depend on observables, roofit will just fall back on our declared BinIntegrator!
  
}
 
Double_t TRooH1::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const {

  //got here, so must have a normFactor that depends on observables
  //we will need to step through our bins, get our val and multiply it by the integrals of any dependent normfactor
  //remember to divide out the included norm factor value: FIXME: what if the normfactor is 0 at evaluation point, but nonzero in other parts of bin!?
  
  if(code==0) return getBinContent();
  
  std::cout << "got code " << code << std::endl;
  
  //FIXME: we assume 1D case for now!
  
  RooFIter nf = fNormFactors.fwdIterator();
  RooAbsReal* arg;
  RooArgList dependentNf;
  RooArgList dependentNfIntegrals;
  TString intRange = Form("%s_intRange",GetName()); //we will change this range to match the bin edges as we loop over bins
  while( (arg = (RooAbsReal*)nf.next()) ) {
    if(arg->dependsOn(fObservables)) {
      dependentNf.add(*arg);
      dependentNfIntegrals.addOwned( *arg->createIntegral( RooArgSet(fObservables) , intRange ) );
    }
  }
  
  RooAbsRealLValue* obs = dynamic_cast<RooAbsRealLValue*>(&fObservables[0]);
  
  //RooAbsBinning&
  const RooAbsBinning* obs_bins = obs->getBinningPtr(GetName());
  
  std::unique_ptr<TIterator> dnf(dependentNf.createIterator());
  std::unique_ptr<TIterator> dnfInt(dependentNfIntegrals.createIterator());
  
  double out(0.);
  for(int k=1;k<= (obs ? obs_bins->numBins() : 0);k++) {
    obs->setVal( obs_bins->binCenter(k-1) );
    if(!obs->inRange(rangeName)) continue;
    double binVal = getBinContent();
    obs->getBinning(intRange).setRange(obs_bins->binLow(k-1),obs_bins->binHigh(k-1));
    //divide out dependent normFactors
    dnf->Reset();dnfInt->Reset();
    while( (arg = (RooAbsReal*)dnf->Next()) ) {
      double oldVal = arg->getVal();
      double inte = ((RooAbsReal*)dnfInt->Next())->getVal();
      std::cout << arg->GetName() << " value in bin " << k << " obsVal=" << obs->getVal() <<" is " << oldVal << " integral = " << inte << std::endl;
      binVal /= arg->getVal();
      binVal *= inte;
      out += binVal;
    }
  }
  return out;

}

*/

//_____________________________________________________________________________
Double_t TRooH1::getValV(const RooArgSet* nset) const
{
  if(kUseAbsPdfValV) return RooAbsPdf::getValV(nset);
  ///THIS CODE IS COPIED FROM BUT SLIGHTLY MODIFIED VERSION OF RooAbsPdf::getValV
  ///DONE TO SUPPRESS WARNINGS ABOUT NEGATIVE VALUES
  
  // Return current value, normalizated by integrating over
  // the observables in 'nset'. If 'nset' is 0, the unnormalized value. 
  // is returned. All elements of 'nset' must be lvalues
  //
  // Unnormalized values are not cached
  // Doing so would be complicated as _norm->getVal() could
  // spoil the cache and interfere with returning the cached
  // return value. Since unnormalized calls are typically
  // done in integration calls, there is no performance hit.

  // Fast-track processing of clean-cache objects
  //   if (_operMode==AClean) {
  //     cout << "RooAbsPdf::getValV(" << this << "," << GetName() << ") CLEAN  value = " << _value << endl ;
  //     return _value ;
  //   }

  // Special handling of case without normalization set (used in numeric integration of pdfs)
  if (!nset) {
    RooArgSet* tmp = _normSet ;
    _normSet = 0 ;
    Double_t val = evaluate() ;
    _normSet = tmp ;
    Bool_t error = (TMath::IsNaN(val)) ? traceEvalPdf(val) : false; //allows negative and zero values

    if (error) {
//       raiseEvalError() ;
      return 0 ;
    }
    return val ;
  }


  // Process change in last data set used
  Bool_t nsetChanged(kFALSE) ;
  if (nset!=_normSet || _norm==0) {
    nsetChanged = syncNormalization(nset) ;
  }

  // Return value of object. Calculated if dirty, otherwise cached value is returned.
  if (isValueDirty() || nsetChanged || _norm->isValueDirty()) {

    // Evaluate numerator
    Double_t rawVal = evaluate() ;
    Bool_t error = (TMath::IsNaN(rawVal)) ? traceEvalPdf(rawVal) : false; //allows negative and zero values // Error checking and printing

    // Evaluate denominator
    Double_t normVal(_norm->getVal()) ;
    
    //add the missing bin, if its defined
    //if(fMissingBinProxy.absArg()) normVal += fMissingBinProxy;
    //if(fMissingBin) normVal += fMissingBin->getVal();
    
//     if (normVal<=0.) {
//       error=kTRUE ;
//       logEvalError("p.d.f normalization integral is zero or negative") ;  
//     }

    // Raise global error flag if problems occur
    if (error) {
//       raiseEvalError() ;
      _value = 0 ;
    } else {
      _value = rawVal / normVal ;
//       cout << "RooAbsPdf::getValV(" << GetName() << ") writing _value = " << rawVal << "/" << normVal << " = " << _value << endl ;
    }

    if(rawVal==0 && normVal==0) _value=1;
    if(kMustBePositive && _value < fFloorValue) _value=fFloorValue;

    clearValueAndShapeDirty() ; //setValueDirty(kFALSE) ;
  } 

  return _value ;
}




