/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TRooFit/TRooH1.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "RooAbsLValue.h"
#include "RooRealVar.h"
#include "RooProdPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooProduct.h"
#include "RooAddition.h"
#include "RooConstVar.h"

#include "RooDataSet.h"
#include "RooDataHist.h"

#include "RooNumIntConfig.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"

#include "RooCachedReal.h"

#include "RooBinning.h"

#include "TRooFit/TRooHStack.h"

#include <memory>

#include "TGraphErrors.h"

ClassImp(TRooH1) 
ClassImp(TRooH0D) 


void TRooAbsH1::UseCurrentStyle() {
  if(!gStyle) return;
  SetLineColor(gStyle->GetHistLineColor());
  SetFillStyle(gStyle->GetHistFillStyle());
  SetFillColor(gStyle->GetHistFillColor());
  SetLineStyle(gStyle->GetHistLineStyle());
}

TRooAbsH1::TRooAbsH1(const RooArgList& observables, RooAbsArg* me) : 
	fObservables((observables.getSize()>0)?"obs":"!obs","obs",me),
	fNormFactors("!normFactors","normFactors",me),
        fShapeFactors("!shapeFactors","shapeFactors",me),
        fStatFactors("!statFactors","statFactors",me),
        fMissingBinProxy("!missing","missing",me) {
  fObservables.add(observables);
  fStatFactors.takeOwnership();//default is to own the stat factors .. TRooHStacks can acquire ownership though
  UseCurrentStyle();
}

TRooH1::TRooH1(const char* name, const char* title) : TRooH1(name,title,RooArgList(),{},{},{}) {

}

TRooH1::TRooH1(const char *name, const char *title,
	      const RooArgList& observables, std::vector<int>&& bins, std::vector<double>&& min, std::vector<double>&& max ) : 
	      TRooH1(name,title,observables,&bins[0],&min[0],&max[0]) {
	      
}



 TRooH1::TRooH1(const char *name, const char *title, 
                        const RooArgList& observables, TH1* hist) :
   RooAbsPdf(name,title), TRooAbsH1(observables,this),
   
   fParameters("!pars","pars",this),
   fValues("!vals","!vals",this)/*,
   fTransFactor("!transFactor","transFactor",this)*/
   
{ 
  //Only experts should construct TRooH1 directly. Please use derived classes (e.g. TRooH1D)

  //FIXME: should do checks on hist dimensions 
  fHists.push_back( (TH1*)hist->Clone(name) );
 fHists[0]->SetDirectory(0);
  fParameterSnapshots.resize(1); //creates an empty vector
  fDummyHist = fHists[0];
  
}

 TRooH1::TRooH1(const char *name, const char *title, 
                        const RooArgList& observables, const int* bins, const double* min, const double* max) :
   RooAbsPdf(name,title), TRooAbsH1(observables,this),
   
   fParameters("!pars","pars",this),
   fValues("!vals","!vals",this)/*,
   fTransFactor("!transFactor","transFactor",this)*/
   
{ 
  //Only experts should construct TRooH1 directly. Please use derived classes (e.g. TRooH1D)

 
  //add binning to the continuous observables
  //also store the binnings and category sizes
  int j=0;
  for(int i=0;i<fObservables.getSize();i++) {
    if(fObservables[i].IsA() == RooRealVar::Class()) {
      static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(min[j],max[j],bins[j]),name);j++;
    } else if(fObservables[i].IsA() == RooCategory::Class()) {
      RooCategory& cat = static_cast<RooCategory&>(fObservables[i]);
      std::unique_ptr<TIterator> itr( cat.typeIterator() );
      RooCatType* tt = 0;
      while( (tt = (RooCatType*)itr->Next()) ) {
        cat.addToRange(GetName(),tt->GetName());
      }
    }
  }
  
//   //update axis in parent TH1
//   fNCells = 1;
//   switch(fObservables.getSize()) {
//     case 3: fZaxis.Set(bins[2],min[2],max[2]); fNCells *= (bins[2]+2);
//     case 2: fYaxis.Set(bins[1],min[1],max[1]); fNCells *= (bins[1]+2);
//     case 1: fXaxis.Set(bins[0],min[0],max[0]); fNCells *= (bins[0]+2);
//   }
//   fDimension=fObservables.getSize();
  
  //create the default hist
  if(fObservables.getSize()==0) {
    fHists.push_back( new TH1D(name,title,1,-0.5,0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
  } else if(fObservables.getSize()==1) {
    if(fObservables[0].IsA() == RooCategory::Class()) { 
      RooCategory& cat = static_cast<RooCategory&>(fObservables[0]);
      fHists.push_back( new TH1D(name,title,cat.numTypes(),-0.5,cat.numTypes()-0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    } else {
       fHists.push_back( new TH1D(name,title,bins[0],min[0],max[0]) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    }
    specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
  } else if(fObservables.getSize()==2) {
    fHists.push_back( new TH2D(name,title,bins[0],min[0],max[0],bins[1],min[1],max[1]) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
  } else {
    std::cout << "not supported!" << std::endl;
  }
 
  fParameterSnapshots.resize(1); //creates an empty vector
  fDummyHist = fHists[0];
  
 
} 

 TRooH1::TRooH1(const char *name, const char *title, 
                        const RooArgList& observables, std::vector<int>&& bins, std::vector<const Double_t*>&& binEdges ) :
   RooAbsPdf(name,title), TRooAbsH1(observables,this),
   fParameters("!pars","pars",this),
   fValues("!vals","!vals",this)/*,
   fTransFactor("!transFactor","transFactor",this)*/
{ 
  //Only experts should construct TRooH1 directly. Please use derived classes (e.g. TRooH1D)

  //add binning to the continuous observables
  //also store the binnings and category sizes
  int j=0;
  for(int i=0;i<fObservables.getSize();i++) {
    if(fObservables[i].IsA() == RooRealVar::Class()) {
      static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(bins[j],binEdges[j]),name);j++;
    } else if(fObservables[i].IsA() == RooCategory::Class()) {
      RooCategory& cat = static_cast<RooCategory&>(fObservables[i]);
      std::unique_ptr<TIterator> itr( cat.typeIterator() );
      RooCatType* tt = 0;
      while( (tt = (RooCatType*)itr->Next()) ) {
        cat.addToRange(GetName(),tt->GetName());
      }
    }
  }
  
//   //update axis in parent TH1
//   fNCells = 1;
//   switch(fObservables.getSize()) {
//     case 3: fZaxis.Set(bins[2],binEdges[2]); fNCells *= (bins[2]+2);
//     case 2: fYaxis.Set(bins[1],binEdges[1]); fNCells *= (bins[1]+2);
//     case 1: fXaxis.Set(bins[0],binEdges[0]); fNCells *= (bins[0]+2);
//   }
//   fDimension=fObservables.getSize();
  
  //create the default hist
  if(fObservables.getSize()==0) {
    fHists.push_back( new TH1D(name,title,1,-0.5,0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
  } else if(fObservables.getSize()==1) {
    if(fObservables[0].IsA() == RooCategory::Class()) { 
      RooCategory& cat = static_cast<RooCategory&>(fObservables[0]);
      fHists.push_back( new TH1D(name,title,cat.numTypes(),-0.5,cat.numTypes()-0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    } else {
       fHists.push_back( new TH1D(name,title,bins[0],binEdges[0]) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    }
    specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
  } else if(fObservables.getSize()==2) {
    fHists.push_back( new TH2D(name,title,bins[0],binEdges[0],bins[1],binEdges[1]) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
  } else {
    std::cout << "not supported!" << std::endl;
  }
 
  fParameterSnapshots.resize(1); //creates an empty vector
  fDummyHist = fHists[0];
  
} 


TRooH1::TRooH1(const TRooH1& other, const char* name) :  
   RooAbsPdf(other,name), TRooAbsH1(other,this),
   fParameters(other.fParameters.GetName(),this,other.fParameters),
   fValues(other.fValues.GetName(),this,other.fValues),
   fHists(other.fHists),
   fFunctionalBinValues(other.fFunctionalBinValues),
   fParameterSnapshots(other.fParameterSnapshots),
   fTransFactor(other.fTransFactor),kIsTransNumerator(other.kIsTransNumerator)
{

}



TRooAbsH1::TRooAbsH1(const TRooAbsH1& other, RooAbsArg* me) :
  TAttLine(other), TAttFill(other), TAttMarker( other ),
  fObservables(other.fObservables.GetName(),me,other.fObservables),
  fNormFactors(other.fNormFactors.GetName(),me,other.fNormFactors),
  fShapeFactors(other.fShapeFactors.GetName(),me,other.fShapeFactors),
  fStatFactors(other.fStatFactors.GetName(),me,other.fStatFactors),
  fBinsShapeFactors(other.fBinsShapeFactors),
  fRangeName(other.fRangeName),
  fDummyHist(other.fDummyHist),
  kUseAbsPdfValV(other.kUseAbsPdfValV),
  kMustBePositive(other.kMustBePositive),
   fMissingBin(other.fMissingBin),
   fMissingBinProxy(other.fMissingBinProxy.GetName(),me,other.fMissingBinProxy)
{ 
  if(fRangeName=="") fRangeName=other.GetName(); //FIXME: should we default the fRangeName to name in constructor?
} 


void TRooH1::isData(bool forceBinned) {
  //EXPERIMENTAL: do not use

  if(fData) { Warning("isData","Already configured for data"); return; }
  
  
  
  //we will combine observables with discrete parameters 
  //will also check we have no continuous parameters

  RooArgSet obsAndCat; obsAndCat.add(fObservables);
  
  RooFIter parItr(fParameters.fwdIterator());
  while(auto par = parItr.next() ) {
    if(par->InheritsFrom( RooAbsCategory::Class() )) {
      obsAndCat.add(*par);
    } else {
      //found a continuous parameter ... exit
      Error("isData","TRooH1 with continuous parameter %s cannot be made into data",par->GetName());
      return;
    }
  }
  
  bool doBinned = forceBinned;
  if(!doBinned) {
    //check if we have any entries in our hists ... if so we must do binned 
    for(auto& hist : fHists) {
      if(hist->GetEntries()>0) { 
        Warning("isData","Constructing binned data....");
        doBinned=true; break;
      }
    }
  }
  
  if(doBinned) {
    fData = new RooDataHist(Form("%s_data",GetName()),GetTitle(),obsAndCat,GetName()); //uses our binning for continuous observables 
    //FIXME: Add existing data
  } else {
    fDataWeightVar = new RooRealVar(Form("%s_weight",GetName()),Form("%s_weight",GetName()),1);
    obsAndCat.add(*fDataWeightVar);
    fData = new RooDataSet(Form("%s_data",GetName()),GetTitle(),obsAndCat,fDataWeightVar->GetName());
  }
  
}

RooAbsReal* TRooAbsH1::createIntegralWM(const RooArgSet& iset,const char* rangeName) const {
  //Create integral with missing events include (WM=With Missing)
  //
  //Returns a function that represents the integral (over iset), including the 'missing events' 
  //user is responsible for deleting the function 
  
  //FIXME: Will need overriding in stacks, to combine all missing bins
  
  RooAbsReal* inte = dynamic_cast<const RooAbsReal*>(this)->createIntegral(iset,rangeName);
  
  if(!fMissingBin) return inte;
  
  //add the missing component 
  return new RooAddition(Form("intWM_%s",GetName()),Form("Integral of %s with missing events",GetTitle()),RooArgList(*inte,*fMissingBin));
  
  
}

 
TRooH1* TRooH1::createTransFactor( TRooH1* transferFrom ) {
  //A transFactor is ..

  if(fTransFactor) {
    Error("createTransFactor","%s: Transfer factor already exists",GetName());
    return fTransFactor;//static_cast<TRooH1*>(fTransFactor.absArg());
  }
  
  //FIXME add binning consistency checks between me and denominator etc etc
  
  TRooH1* transFactor = new TRooH1( Form("trans_%s_%s",GetName(),transferFrom->GetName()), "Transfer factor", fObservables, fHists[0] );
  
  kIsTransNumerator = true;
  fTransFactor = transFactor;
  addNormFactor( *transferFrom ); addNormFactor( *transFactor );
  
  transferFrom->fTransFactor = transFactor;//transferFrom->fTransFactor.SetName("transFactor");
  //NOTE: should we remove the fParameters from the denominator?
  
  //need to compute transfer factors from existing histograms
  //first copy over all the numerator hists and paramsets 
  transFactor->fParameters.add( fParameters ); 
  if(fParameters.getSize()) transFactor->fParameters.setName("pars"); 
  transFactor->fParameterSnapshots = fParameterSnapshots;
  //duplicate each histogram too, already did first one above
  for(uint i=1;i<fHists.size();i++) {
    transFactor->fHists.push_back( (TH1*)fHists[i]->Clone(GetName()) );
    transFactor->fHists.back()->SetDirectory(0);
  }
  
  
  
  //now go through and divide each hist by the corresponding hist in the denominator
  RooArgSet ss; fParameters.snapshot(ss); //save state of parameters 
  for(uint i=0;i<fParameterSnapshots.size();i++) {
    for(uint j=0;j<fParameterSnapshots[i].size();j++) {
      if(fParameters[j].InheritsFrom(RooAbsCategory::Class())) {
        (dynamic_cast<RooAbsCategoryLValue&>(fParameters[j])).setIndex(int(fParameterSnapshots[i][j]+0.5));
      } else {
        (dynamic_cast<RooAbsRealLValue&>(fParameters[j])).setVal(fParameterSnapshots[i][j]);
      }
    }
    //parameters aligned, now get the histogram 
    int pset = transferFrom->getParamSet();
    if(pset==-1) {
      Error("createTransFactor","Failed to get denominator histogram");
    } else {
      //TH1* h0 = transFactor->fHists[i]; don't use h0 directly, use SetBinContent method so that can propagate to further transFactors
      TH1* h1 = fHists[i];
      TH1* h2 = transferFrom->GetHist(pset);
      int nbinsz = (h1->GetDimension()<3) ? -1 : h1->GetNbinsZ();
      int nbinsy = (h1->GetDimension()<2) ? -1 : h1->GetNbinsY();
      int nbinsx = h1->GetNbinsX();
      //follow convention that if two bins are both 0, then the transfer factor is actually 1!
      double b1,b2;
      for(int binz=0;binz<=nbinsz+1;binz++) {
        for(int biny=0;biny<=nbinsy+1;biny++) {
          for(int binx=0;binx<=nbinsx+1;binx++) {
            int bin=binx+(nbinsx+2)*(biny + (nbinsy+2)*binz);
            b1 = h1->GetBinContent(bin);b2 = h2->GetBinContent(bin);
            if(b2==0 && b1==0) transFactor->SetBinContent(bin,1);
            else if(b2==0) {
              Warning("createTransferFactor","denominator zero in bin %d ... setting transFactor to 0",bin);
              transFactor->SetBinContent(bin,0);
            } else transFactor->SetBinContent( bin, b1/b2 );
          }
        }
      }
    }
  }
  fParameters = ss; //resets parameter values
  
  
  return transFactor;
}

bool TRooAbsH1::addNormFactor( RooAbsReal& factor ) {
  //Add an overall normalization factor to this TRooFit pdf 
  //If you want the factor to be constrained, you should specify a 
  //constraintType property on the factor 
  //
  //Available constraintTypes: (set with factor.setStringAttribute("constraintType","TYPE") )
  //   normal : constrained by 0, with stdev = 1
  //   gaussian(x,y) : constrained by x, with stdev = y    [gaussian(0,1) == normal]
  

  if(fNormFactors.find( factor )) return false;
  fNormFactors.add( factor ); fNormFactors.setName("normFactors");
  if(fMissingBin) { fMissingBin->addNormFactor( factor ); }
  //need to also tell all clients that we have a new parameter to depend on
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->addServer(factor);client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  return true;
}

bool TRooAbsH1::addShapeFactor( int bin, RooAbsReal& factor ) {
  //Add a normalization factor to a specific bin of this TRooFit pdf 
  //If you want the factor to be constrained, you should specify a 
  //constraintType property on the factor. See TRooAbsH1::addNormFactor for more info.

  if(!fShapeFactors.find( factor )) {
    fShapeFactors.add( factor ); fShapeFactors.setName("shapeFactors");
    //need to also tell all clients that we have a new parameter to depend on
    TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
    while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
      client->addServer(factor);client->setValueDirty();client->setShapeDirty();
    }
    delete citer;
  }
  fBinsShapeFactors[bin].push_back( fShapeFactors.index( &factor ) );
  return true;
}

bool TRooAbsH1::addShapeFactor( const char* bin, RooAbsReal& factor ) {
  //Same as the other addShapeFactor method, but can be used when the 
  //first (i.e. x-axis) observable of this histogram is a discrete variable

  //first observable must be a category
  if(GetDimension()==0) return addShapeFactor(1,factor);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("addShapeFactor","%s is not a category, cannot fill",fObservables[0].GetName());
    return false;
  }
  auto type = cat->lookupType(bin);
  if(!type) {
    Error("addShapeFactor","%s unknown label in %s",bin,fObservables[0].GetName());
    return false;
  }
  return addShapeFactor( type->getVal() + 1 , factor );
  
}


bool TRooH1::addParameter( RooAbsArg& arg ) { 
  //Use this method to turn this TRooFit histogram into a function of the given parameter, arg.
  //All the previously filled values of the histogram will be assumed to correspond 
  //to the current value of the parameter 
  //
  //You can then change the value of the parameter and start to re-fill the histogram 
  //This will then make the histogram correspond to a coherent variation. 
  //
  //Linear interpolation of the bin contents is performed for intermediate values of the 
  //parameter.

  if(fParameters.find(arg)) return false; //already added
  if(fData) {
    if(!arg.InheritsFrom(RooAbsCategory::Class())) {
      Error("addParameter","Can only add category parameters to data");
      return false;
    }
    if(fData->InheritsFrom(RooDataSet::Class())) {
      ((RooDataSet*)fData)->addColumn(arg);
    } else {
      //FIXME: add observable for RooDataHist!?
    }
  }
  
  
  fParameters.add(arg); fParameters.setName("pars");
  if(fMissingBin) fMissingBin->addParameter(arg);
  //add a clone to all existing paramsets too
  double val = (arg.InheritsFrom(RooAbsCategory::Class())) ? static_cast<RooAbsCategory&>(arg).getIndex() : static_cast<RooAbsReal&>(arg).getVal();
  for(auto& pars : fParameterSnapshots) {
    pars.push_back(val);
  }
  
  //need to also tell all clients that we have a new parameter to depend on
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->addServer(arg);client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}

std::unique_ptr<RooArgSet> TRooAbsH1::GetShapeFactors(int bin) const {
  std::unique_ptr<RooArgSet> out(new RooArgSet(Form("%s_shapeFactors_bin%d",GetName(),bin)));
  if(fBinsShapeFactors.find(bin)==fBinsShapeFactors.end()) return out;
  
  for(auto fIdx : fBinsShapeFactors.at(bin)) {
    out->add( *fShapeFactors.at(fIdx) );
  }
  return out;
  
}

void TRooH1::FillMissing(double w) {
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->Fill(w);
}
void TRooH1::SetMissingContent(double w) {
  if(!fMissingBin) {
    fMissingBin = new TRooH0D(Form("%s_missed",GetName()),Form("Missed part of %s",GetTitle()));
    fMissingBinProxy.setArg(*fMissingBin);
    fMissingBinProxy.SetName("missing"); //so it shows up in Print
    //propagate all normFactors!
    for(int i=0;i<fNormFactors.getSize();i++) {
      fMissingBin->addNormFactor(static_cast<RooAbsReal&>(fNormFactors[i]));
    }
  }
  fMissingBin->SetBinContent(1,w);
}



Bool_t TRooH1::Add(const TH1* h1 , Double_t c1) {
  int pset = getOrCreateParamSet();
  bool out = fHists[pset]->Add(h1,c1);
  
  if(out && pset==0) { //add succeeded, and was adding to 'nominal' set, so adjust stat factors
    for(int i=1;i<=h1->GetNbinsX();i++) {
      for(int j=1;j<=h1->GetNbinsY();j++) {
        for(int k=1;k<=h1->GetNbinsZ();k++) {
          int bin = h1->GetBin(i,j,k);
          if(!h1->GetBinError(bin)) continue; //don't need to adjust if there was no error
          RooRealVar* statFactor = getStatFactor(bin); //first try without creating 
          if(!statFactor) { 
            statFactor = getStatFactor(bin, true);  //automatically sets sumw and sumw2 for us when creating a new statFactor
          } else {
            //update the sumw and sumw2 attribute of the stat factor
            statFactor->setStringAttribute("sumw",Form("%f",(TString(statFactor->getStringAttribute("sumw")).Atof() + h1->GetBinContent(bin))));
            statFactor->setStringAttribute("sumw2",Form("%f",(TString(statFactor->getStringAttribute("sumw2")).Atof() + pow(h1->GetBinError(bin),2))));
            //will also set the error to sqrt(sumw2)/sumw
            statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
          }
        }
      }
    }
  }
  return out;
}


Int_t TRooH1::Fill( double x , double w ) {
  //The usual histogram Fill method
  //This method will trigger the automatic creation of parameters (as necessary) 
  // to represent the statistical uncertainty in the filled bin 

  int pset = getOrCreateParamSet();
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { w = x; x = 0; } //in the counting-mode, the x variable is always "0"
  
  //only create stat factors when filling the 'nominal' histogram
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin, true);
    //update the sumw and sumw2 attribute of the stat factor
    statFactor->setStringAttribute("sumw",Form("%f",(TString(statFactor->getStringAttribute("sumw")).Atof() + w)));
    statFactor->setStringAttribute("sumw2",Form("%f",(TString(statFactor->getStringAttribute("sumw2")).Atof() + w*w)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    
  }
  
  //temporarily move the relevent observable onto our value
  if(fData) {
    RooArgSet obsAndPars; obsAndPars.add(fObservables); obsAndPars.add(fParameters);
    if(fDataWeightVar) fDataWeightVar->setVal(w);
    if(fObservables.getSize()) {
      if(fObservables[0].InheritsFrom(RooCategory::Class())) {
        RooCategory& c = dynamic_cast<RooCategory&>(fObservables[0]);
        int tmpIdx = c.getIndex();
        c.setIndex(x);
        fData->add( obsAndPars , w );
        c.setIndex(tmpIdx);
      } else {
        RooAbsRealLValue& v = dynamic_cast<RooAbsRealLValue&>(fObservables[0]);
        double tmpVal = v.getVal();
        v.setVal(x);
        fData->add( obsAndPars , w );
        v.setVal(tmpVal);
      }
    } else {
      //0D case ... just fill!
      fData->add( obsAndPars , w );
    }
  }
  
  
  return fHists[pset]->Fill(x,w);
  
  //FIXME: propagate changes to transFactor if there is one!
  
}

Int_t TRooH1::Fill( const char* name , double w ) {
  //Same as above, but can use name of Category type
  
  if(GetDimension()==0) return Fill(0.,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("Fill","%s is not a category, cannot fill",fObservables[0].GetName());
    return -1;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("Fill","%s unknown label in %s",name,fObservables[0].GetName());
    return -1;
  }
  return Fill( type->getVal() , w );
  
}

  
Int_t TRooH1::Fill( Double_t x, RooAbsReal& val ) {
  //Fills (i.e. adds) a function to bin at x value, 
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { bin = -1; } 
  
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return fValues.index(&val);
  
}


Int_t TRooH1::Fill( RooAbsReal& val ) {
  //fill every bin with this function
  
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
    
  fFunctionalBinValues[-1].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return 0;
  
}

RooRealVar* TRooAbsH1::getStatFactor(int bin, bool createIf) {
    //create a stat factor for this bin, unless one already exists

    if(fBinsShapeFactors.find(bin)!=fBinsShapeFactors.end()) {
      for(auto fIdx : fBinsShapeFactors.at(bin)) {
        if(fStatFactors.find(*fShapeFactors.at(fIdx))) { return (RooRealVar*)fShapeFactors.at(fIdx); }
      }
    }
    
    //first check if we are a stack ... because possible we can find a stat factor from the components
    if(dynamic_cast<TObject*>(this)->InheritsFrom(TRooAbsHStack::Class())) {
      RooFIter statFactors = fStatFactors.fwdIterator();
      RooRealVar* factor;
      while( ( factor = (RooRealVar*)statFactors.next() ) ) {
        if(TString(factor->getStringAttribute("statBinNumber")).Atoi()==bin) return factor;
      }
    }
    
    
    if(!createIf) return 0; //stop here 
    
    //ok, going to create a statFactor ... first check if we are actually part of a stack
    TRooAbsHStack* stack = 0;
    if(!fStatFactors.isOwning()) { //stack owns stat 
      //look for a stack in our clients ... add our stat factor there
      std::unique_ptr<TIterator> clients(clientIterator());
      
      while(TObject* a = clients->Next()) {
        if(a->InheritsFrom(TRooAbsHStack::Class())) { stack = (TRooAbsHStack*)a; break; }
      }
      if(!stack) { std::cout << "COULD NOT FIND MY STACK!???" << std::endl; }
      else {
        //see if there's a good stat variable in the stack we can use
        RooFIter statFactors = stack->fStatFactors.fwdIterator();
        RooRealVar* factor;
        while( ( factor = (RooRealVar*)statFactors.next() ) ) {
          if(TString(factor->getStringAttribute("statBinNumber")).Atoi()==bin) {
            //found a good statFactor .. we now must add the content and sumw2 of ourselves
            factor->setStringAttribute("constraintType","statPoisson");
            factor->setStringAttribute("sumw",Form("%f",(TString(factor->getStringAttribute("sumw")).Atof() + getNominalHist()->GetBinContent(bin)))); 
            factor->setStringAttribute("sumw2",Form("%f",(TString(factor->getStringAttribute("sumw2")).Atof() + pow(getNominalHist()->GetBinError(bin),2)))); 
            factor->setError(sqrt((TString(factor->getStringAttribute("sumw2")).Atof()))/(TString(factor->getStringAttribute("sumw")).Atof()));
            addShapeFactor( bin, *factor );
            return factor;
          }
        }
      }
    }
    
    //got here, ok just have to create a new factor 
    RooRealVar* statFactor = new RooRealVar(Form("%s_stat_bin%d",(stack)?stack->GetName():GetName(),bin),Form("Stat factor bin %d",bin),1,0,5);
    statFactor->setStringAttribute("statBinNumber",Form("%d",bin));
    statFactor->setStringAttribute("constraintType","statPoisson");
    statFactor->setStringAttribute("sumw",Form("%f",getNominalHist()->GetBinContent(bin))); 
    statFactor->setStringAttribute("sumw2",Form("%f",pow(getNominalHist()->GetBinError(bin),2))); 
    if(getNominalHist()->GetBinError(bin)) {
      statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    }
    if(!stack) {
      fStatFactors.addOwned(*statFactor); fStatFactors.setName("statFactors");
    } else {
      stack->fStatFactors.addOwned(*statFactor); //add to stack's statFactors
      fStatFactors.add(*statFactor); //add to my own list of stat factors
    }
    addShapeFactor(bin,*statFactor);
    return statFactor; 
    

}

//used in modifying methods, like SetBinContent, Fill, SetBinError etc
Int_t TRooH1::getOrCreateParamSet() {
  setValueDirty();
  //we have to dirty up ALL clients, not just those who have said they are value clients
  //integrals don't think of themselves as value clients because they think they integrate out changes in our value
  //i.e. they assume the only way a function can change value is if the servers change values
  //and so the only way THEY can change value is if the non-integrated servers change value
  
  TIterator* citer(clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  

  int pset = getParamSet();
  
  if(pset==-1) { //need to create a new hist, clone the "nominal" hist
    std::vector<double> parVals;
    //get the current paramter values
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      if(par->InheritsFrom( RooAbsCategory::Class() )) {
        parVals.push_back( ((RooAbsCategory*)par)->getIndex() );
      } else {
        parVals.push_back( ((RooAbsReal*)par)->getVal() );
      }
    }
    fParameterSnapshots.push_back(parVals);
    fHists.push_back( (TH1*)fHists[0]->Clone( Form("%s_variation%d",GetName(),int(fParameterSnapshots.size()))) ); 
    fHists.back()->SetDirectory(0);
    fHists.back()->Reset();
    pset = fParameterSnapshots.size()-1;
    
    
  }
  return pset;
}

void TRooH1::SetBinContent( int bin, double val ) {
  //Set the contents of a given bin

  int pset = getOrCreateParamSet();
  //update the statFactor's sumw, if necessary
  if(pset==0 && fHists[pset]->GetBinContent(bin)) {
    RooRealVar* statFactor = getStatFactor(bin);
    if(statFactor) {
      statFactor->setStringAttribute("sumw",Form("%f",(TString(statFactor->getStringAttribute("sumw")).Atof() - fHists[pset]->GetBinContent(bin) + val)));
      //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    }
  }
  fHists[pset]->SetBinContent(bin,val);
  //FIXME: propagate changes to transFactor if there is one!
}

void TRooH1::SetBinContent( const char* name , double w ) {
  //Set the contents of a given bin 
  //The first observable of this TRooH1 must be a RooCategory

  //first observable must be a category
  if(GetDimension()==0) SetBinContent(1,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("SetBinContent","%s is not a category, cannot fill",fObservables[0].GetName());
    return;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("SetBinContent","%s unknown label in %s",name,fObservables[0].GetName());
    return;
  }
  SetBinContent( type->getVal() + 1 , w );
  
}

void TRooH1::SetBinError( int bin, double error ) {
  int pset = getOrCreateParamSet();
  
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin,true);
    //update the sumw2 attribute of the stat factor ... 
    //the factor might be shared if its in a stack, so must subtract old error and add new one
    statFactor->setStringAttribute("sumw2",Form("%f",(TString(statFactor->getStringAttribute("sumw2")).Atof() - pow(fHists[pset]->GetBinError(bin),2) + error*error)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
  } else {
    Warning("SetBinError","Bin errors only used when in nominal histogram");
  }
  
  fHists[pset]->SetBinError(bin,error);
  
}

Int_t TRooAbsH1::FindFixBin( double x ) const {

  return fDummyHist->FindFixBin(x); //just use the hist

  int out = 0; int factor = 1;
  for(int i=0;i<fObservables.getSize();i++) {
    double bin = 0;
    if(i==0) {
      //use x value to get bin
      if( fObservables[i].InheritsFrom( RooAbsCategory::Class() ) ) {
        bin = int(x+0.5); //assume x is an index
      } else {
        auto binning = dynamic_cast<RooAbsLValue&>(fObservables[i]).getBinningPtr(GetRangeName());
        if(x < binning->lowBound()) bin = 0;
        else if(x > binning->highBound()) bin = binning->numBins()+1;
        else bin = binning->binNumber(x)+1;
      }
    }
    
    
    out += factor*bin;
    
    if( fObservables[i].InheritsFrom( RooAbsCategory::Class() ) ) {
      //discrete variable, so no need to cover for overflows
      out -= factor;
      //now increase factor by number of categories
      factor *= static_cast<RooAbsCategory&>(fObservables[i]).numTypes();
    } else {
      factor *= (static_cast<RooRealVar&>(fObservables[i]).numBins()+2);
    }
    
    //increase factor by number of bins (if observable was category) or bins + 2 (if continuous)
  }
  return out;
}

Double_t TRooAbsH1::getBinVolume() const {
  double out = 1.;
  RooFIter itr(fObservables.fwdIterator());
  RooAbsArg* arg = 0;
  while( (arg = itr.next()) ) {
    if(arg->IsA() != RooRealVar::Class()) continue;
    RooRealVar* v = static_cast<RooRealVar*>(arg);
    out *= v->getBinWidth( v->getBin(GetRangeName()) , GetRangeName() );
  }
  return out;

/*  int dim = GetDimension();
  if(dim==0) return 1;
  
  double out = 1;
  int bb[3]; fHists[0]->GetBinXYZ(getBin(),bb[0],bb[1],bb[2]);
  for(int i=0;i<dim;i++) {
    TAxis* ax = 0; if(i==0) ax = fHists[0]->GetXaxis(); else if(i==1) ax = fHists[0]->GetYaxis(); //FIXME: assumes 2D at most
    out *= ax->GetBinWidth(bb[i]);
  }
  return out;
*/
}



Int_t TRooAbsH1::getBin(const char* rangeName) const {
  if(GetDimension()==0) return 1;
  int out = 0; int factor = 1;
  const char* rName = GetRangeName(rangeName);
  for(int i=0;i<fObservables.getSize();i++) {
    double bin = 0;
    if(!fObservables[i].inRange(rName)) {
      //see if is under or overflow
      if(static_cast<RooRealVar&>(fObservables[i]).getVal() > static_cast<RooRealVar&>(fObservables[i]).getMin(rName))  {
        bin = static_cast<RooRealVar&>(fObservables[i]).numBins(rName)+1;
      }
    } else {
      bin = dynamic_cast<RooAbsLValue&>(fObservables[i]).getBin(rName)+1; 
    }
    out += factor*bin;
    
    if( fObservables[i].InheritsFrom( RooAbsCategory::Class() ) ) {
      //discrete variable, so no need to cover for overflows
      //out -= factor;
      //now increase factor by number of categories
      factor *= (static_cast<RooAbsCategory&>(fObservables[i]).numTypes(rName)+2);
    } else {
      factor *= (static_cast<RooRealVar&>(fObservables[i]).numBins(rName)+2);
    }
    
    //increase factor by number of bins (if observable was category) or bins + 2 (if continuous)
  }
  return out;
}

Double_t TRooAbsH1::GetBinError(int bin, const RooFitResult* fr) const { 
  
    //convert global bin number into local bin, using current GetRangeName ...
  int binx(0),biny(0),binz(0);
  switch(GetDimension()) {
    case 1: binx = bin; break; //simple case
    case 2: binx = bin % (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            biny = bin / (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            break;
    case 3: binx = bin % ((dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2)*(dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2));
            //FIXME biny = bin % (dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2);
            //FIXME binz
  }
  int tmpVals[3] = {0,0,0};
  switch(GetDimension()) {
    case 3: tmpVals[2] = dynamic_cast<RooAbsLValue&>(fObservables[2]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(binz-1,GetRangeName());
    case 2: tmpVals[1] = dynamic_cast<RooAbsLValue&>(fObservables[1]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(biny-1,GetRangeName());
    case 1: tmpVals[0] = dynamic_cast<RooAbsLValue&>(fObservables[0]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(binx-1,GetRangeName());
  }
  double out(0);
  if(fr==0) {
    //create one with anything that isn't my observables 
    RooArgSet* params = getParams(fObservables);
    TRooFitResult r(*params);
    delete params;
    out = getBinError(r);
  } else if(fr->floatParsFinal().getSize()==0) {
      //no floating pars ... error would by definition be zero for this case
      //we assume here that isn't what the user wanted ... instead assume they wanted all parameters 
      //that are not in the constPars list 
      RooAbsCollection* cdeps = getParams(fObservables);
      cdeps->remove(fr->constPars(),true,true);
      RooArgList l; l.add(*cdeps);
      TRooFitResult r(l,fr->constPars());
      out = getBinError(r);
      delete cdeps;
      
      
  } else {
  
    RooAbsCollection* crsnap = 0;
    //also ensure that all non-observables are held constant if they are not specified in the fit result 
    RooAbsCollection* cdeps = getParams(fObservables);
    cdeps->remove(fr->floatParsFinal(),true,true/*remove by name*/);
    crsnap = cdeps->snapshot();
    *cdeps = fr->constPars(); //move constpars to their location  ... shouldn't be necessary now that i added line to getError method to set constPars values
    cdeps->setAttribAll("Constant",true); //hold everything const now
    
    out = getBinError(*fr);
    
    *cdeps = *crsnap; //this will also revert constant status
    delete cdeps;
    delete crsnap;
  }
  switch(GetDimension()) {
    case 3: dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(tmpVals[2],GetRangeName());
    case 2: dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(tmpVals[1],GetRangeName());
    case 1: dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(tmpVals[0],GetRangeName());
  }
  return out;
  

}

Double_t TRooAbsH1::GetBinContent(int bin, const RooFitResult* r) const {
  //convert global bin number into local bin, using current GetRangeName ...
  int binx(0),biny(0),binz(0);
  switch(GetDimension()) {
    case 1: binx = bin; break; //simple case
    case 2: binx = bin % (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            biny = bin / (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            break;
    case 3: binx = bin % ((dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2)*(dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2));
            //FIXME biny = bin % (dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2);
            //FIXME binz
  }
  
  
  //fHists[0]->GetBinXYZ(bin,binx,biny,binz);
  int tmpVals[3] = {0,0,0};
  switch(GetDimension()) {
    case 3: tmpVals[2] = dynamic_cast<RooAbsLValue&>(fObservables[2]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(binz-1,GetRangeName());
    case 2: tmpVals[1] = dynamic_cast<RooAbsLValue&>(fObservables[1]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(biny-1,GetRangeName());
    case 1: tmpVals[0] = dynamic_cast<RooAbsLValue&>(fObservables[0]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(binx-1,GetRangeName());
  }
  RooAbsCollection* deps = 0;RooAbsCollection* cdeps = 0;
  RooAbsCollection* rsnap = 0;RooAbsCollection* crsnap = 0;
  if(r) {
    //move onto finalPars values 
    deps = getDependents(r->floatParsFinal());
    rsnap = deps->snapshot();
    *deps = r->floatParsFinal(); //overrides with values from fit result
    //likewise for constPars 
    cdeps = getDependents(r->constPars());
    crsnap = cdeps->snapshot();
    *cdeps = r->constPars(); cdeps->setAttribAll("Constant",true);
  }
  double out = getBinContent(fObservables);
  if(r) {
    *deps = *rsnap;
    *cdeps = *crsnap; //this will also revert constant status
    delete deps;delete cdeps;
    delete rsnap;delete crsnap;
  }
  switch(GetDimension()) {
    case 3: dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(tmpVals[2],GetRangeName());
    case 2: dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(tmpVals[1],GetRangeName());
    case 1: dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(tmpVals[0],GetRangeName());
  }
  return out;
}


Double_t TRooAbsH1::GetBinContent(const char* bin, const RooFitResult* r) const {
  //first observable must be a category
  if(GetDimension()==0) return GetBinContent(1,r);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("GetBinContent","%s is not a category, cannot fill",fObservables[0].GetName());
    return false;
  }
  auto type = cat->lookupType(bin);
  if(!type) {
    Error("GetBinContent","%s unknown label in %s",bin,fObservables[0].GetName());
    return false;
  }
  return GetBinContent( type->getVal() + 1 , r );
  
}

TAxis* TRooAbsH1::GetXaxis() const {
  //Retrieve the x-axis
  return fDummyHist->GetXaxis();
}

Int_t TRooH1::getParamSet() const {
  //Returns the ID of the current parameter spacepoint 
  //Or if the state of the parameters is an unknown point
  //then this method will return -1.

  if(fParameters.getSize()==0) return 0;
  
  //compare parameter values up to a certain 'precision' for equality
  int i=0;
  for(auto& parVals : fParameterSnapshots) {
    bool match(true);
    
    uint j=0;
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
      double val = 0;
      if(cat) {
        val = cat->getIndex();
      } else {
        val = static_cast<RooAbsReal*>(par)->getVal();
      }
      if( fabs(val - parVals[j]) > 1e-9 ) {match=false;break;}
      j++;
    }
    if(match) return i;
    i++;
  }
  
  return -1;
}


RooAbsPdf& TRooAbsH1::model() {

  //first check if constraints are needed
  RooArgSet* nodes = getParams(fObservables);
  RooFIter itr = nodes->fwdIterator();
  RooAbsArg* arg = 0;
  bool hasConstraint(false);
  while( (arg = itr.next()) ) {
    if(!arg->isFundamental()) continue;
    if(arg->isConstant()) continue;
    if(!arg->getStringAttribute("constraintType")) continue;
    hasConstraint=true; break;
  }
  if(hasConstraint) {
    if(!fThisWithConstraints) fThisWithConstraints = buildConstraints(fObservables,"",true);
    return *fThisWithConstraints;
  }
  return dynamic_cast<RooAbsPdf&>(*this);
}

RooProdPdf* TRooAbsH1::buildConstraints(const RooArgSet& obs, const char* systGroups,bool addSelf) const {
  
  RooProdPdf* out = 0;
  RooArgList constraints; if(addSelf) constraints.add(*dynamic_cast<const RooAbsArg*>(this));
  //find all primitive servers, and for the ones in my systGroups
  //assemble constraints according to constraintType
  //if none given, then leave unconstrained!
  //RooArgSet nodes;
  //treeNodeServerList(&nodes);
  RooArgSet* nodes = getParams(obs);
  RooFIter itr = nodes->fwdIterator();
  RooAbsArg* arg = 0;
  while( (arg = itr.next()) ) {
    if(!arg->isFundamental()) continue;
    if(arg->isConstant()) continue;
    if(!arg->getStringAttribute("constraintType")) {
      Info("buildConstraints","%s is an unconstrained free parameter",arg->GetName());
      continue;
    }
    TString cType = arg->getStringAttribute("constraintType");
    cType.ToUpper();
    if(cType == "STATPOISSON" ) {
      //this factor is poisson constrained to be: gamma = 1 +/- sqrt(sumw2)/sumw
      //this means constraint with Pois(gobs|gamma*tau) where observed gobs=tau,
      //and tau = (sumw)^2/sumw2
      RooConstVar* tau = new RooConstVar(Form("tau_%s",arg->GetName()),Form("tau_%s",arg->GetName()),
                        pow(TString(arg->getStringAttribute("sumw")).Atof(),2)/TString(arg->getStringAttribute("sumw2")).Atof());
      RooRealVar* gobs = new RooRealVar(Form("gobs_%s",arg->GetName()),Form("Global observable for %s",arg->GetName()),
                        tau->getVal());gobs->setConstant();
      RooProduct* mean = new RooProduct(Form("mean_%s",arg->GetName()),"",RooArgList(*arg,*tau));
      RooPoisson* p = new RooPoisson(Form("pois_%s",arg->GetName()),Form("TRooFit-generated constraint for %s",arg->GetTitle()),*gobs,*mean);
      constraints.add(*p);
      
      //also set the error on the parameter if it's error is zero 
      RooRealVar* rrv = dynamic_cast<RooRealVar*>(arg);if(rrv && !rrv->getError()) rrv->setError(1./sqrt(tau->getVal()));
      
    } else if(cType =="NORMAL") {
      Info("buildConstraints","%s is normal(gobs=0,sigma=1) constrained free parameter",arg->GetName());
      //normal constraint
      RooRealVar* gobs = new RooRealVar(Form("gobs_%s",arg->GetName()),Form("Global observable for %s",arg->GetName()),0);gobs->setConstant();
      RooConstVar* sigma = new RooConstVar("1","1",1);
      RooGaussian* p = new RooGaussian(Form("gaus_%s",arg->GetName()),Form("TRooFit-generated constraint for %s",arg->GetTitle()),*gobs,*dynamic_cast<RooAbsReal*>(arg),*sigma);
      constraints.add(*p);
      
      //also set the error on the parameter if it's error is zero 
      RooRealVar* rrv = dynamic_cast<RooRealVar*>(arg);if(rrv && !rrv->getError()) rrv->setError(1.);
      
    } else if(cType.BeginsWith("GAUSSIAN(")) {
      //gaussian ... need to extract the auxObs (aka mean) and stdev from the attribute 
      //syntax is: gaussian(auxObs,stddev)
      double auxObs = TString(cType(9,cType.Index(",")-9)).Atof();
      TString stddevStr = TString(cType(cType.Index(",")+1,cType.Index(")")-(cType.Index(","))-1));
      Info("buildConstraints","%s is gaussian(gobs=%g,sigma=%s) constrained free parameter",arg->GetName(),auxObs,stddevStr.Data());
      RooRealVar* gobs = new RooRealVar(Form("gobs_%s",arg->GetName()),Form("Global observable for %s",arg->GetName()),auxObs);gobs->setConstant();
      RooConstVar* sigma = new RooConstVar(stddevStr,stddevStr,stddevStr.Atof());
      RooGaussian* p = new RooGaussian(Form("gaus_%s",arg->GetName()),Form("TRooFit-generated constraint for %s",arg->GetTitle()),*gobs,*dynamic_cast<RooAbsReal*>(arg),*sigma);
      constraints.add(*p);
      
      //also set the error on the parameter if it's error is zero 
      RooRealVar* rrv = dynamic_cast<RooRealVar*>(arg);if(rrv && !rrv->getError()) rrv->setError(stddevStr.Atof());
      
    } else {
      Warning("buildConstraints","%s has unknown constraintType: %s", arg->GetName(), arg->getStringAttribute("constraintType"));
    }
  }
  delete nodes;
  out = new RooProdPdf((addSelf)?Form("%s_with_Constraints",GetName()):Form("Constraints_of_%s",GetName()),
                       (addSelf)?Form("%s_with_Constraints",GetName()):Form("Constraints_of_%s",GetName()),constraints);
  return out;
}

const std::vector<double>& TRooH1::GetParamSet(int idx) const { 
  //Return the values of the parameters corresponding to paramSet = idx
  //The order of the parameters can be seen through the Print method 
  
  return fParameterSnapshots[idx]; 
}

Double_t TRooH1::evaluate() const 
{
  //The main roofit evaluation method. Users should not call this directly 
  //It is computing the pdf value (the probability density) 

//std::cout << "rangeName = " << GetRangeName() << " "; fObservables.Print("v"); 

  double out = 0;
  int bin = getBin(GetName()); //forcefully use OUR binning 

  //if using transfer factors
  if(fTransFactor && kIsTransNumerator) {
    //numerator will just have value = TransferFactor*Denominator
    //these were both added as NormFactors in createTransFactor
    out = 1;
  
  } else {

    //loop over parameter snapshots, assessing which sets are valid (discrete params must match exactly)
    //if we find an exact match, we go with that
    
    //goal is that for each parameter to obtain the spacepoint IDs for the two closest valid spacepoints
    
    std::vector<int> upSet(fParameters.getSize(),-1); 
    std::vector<int> downSet(fParameters.getSize(),-1); 
    int nomSet = -1;
    
    int pset=-1;
    if(fParameters.getSize()==0 || (fTransFactor && !kIsTransNumerator)) { //always use nominal if we are the denominator
      pset=0;
    } else {
    
      int i=0;
      std::vector<int> setUp;std::vector<int> setDown; //get filled with parameter indices that should get set to up/down
      for(auto& parVals : fParameterSnapshots) {
        bool match(true); bool invalid(false);
        RooFIter parItr(fParameters.fwdIterator());
        int j=0; 
        setUp.clear();setDown.clear();
        while(auto par = parItr.next() ) {
          RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
          if(cat) {
            if( cat->getIndex() != int(parVals[j]+0.5) ) {
              match=false;invalid=true;break;
            }
          } else {
            //record if this is up/down/nom variation for this parameter
            double parVal = ((RooAbsReal*)par)->getVal();
            double parDiff = fabs(parVal - parVals[j]);
            if(parDiff > 1e-9) match=false;
            
            
            if(upSet[j]==-1) setUp.push_back(j); //if valid, will
            else if(downSet[j]==-1) setDown.push_back(j);
            else {
              //replace the one that is further away 
              double upDiff = fabs(fParameterSnapshots[upSet[j]][j] - parVal);
              double downDiff = fabs(fParameterSnapshots[downSet[j]][j] - parVal);
              if(parDiff<upDiff || parDiff<downDiff) {
                if(upDiff>downDiff) setUp.push_back(j);
                else setDown.push_back(j);
              }
            }
          }
          j++;
        }
        if(match) {
          pset=i; 
          break; //can just stop right now, found a perfect match
        }
        if(!invalid) { //if snapshot featured a variation up or down, store that
          if(nomSet==-1) nomSet=i; //the first valid set is used as the nom set
          //signal which parameters this snapshot is a valid variation for
          for(auto& j : setUp) upSet[j]=i;
          for(auto& j : setDown) downSet[j]=i;
        }
        i++;
      }
    }
    
    //add the functional bin values
    if(fFunctionalBinValues.find(-1)!=fFunctionalBinValues.end()) {
      for(auto& vals : fFunctionalBinValues.at(-1)) {
        out += static_cast<RooAbsReal&>(fValues[vals]).getVal();
      }
    }
    if(fFunctionalBinValues.find(bin) != fFunctionalBinValues.end()) {
      for(auto& vals : fFunctionalBinValues.at(bin)) {
        out += static_cast<RooAbsReal&>(fValues[vals]).getVal();
      }
    }
    

    if(pset!=-1) {
      //add the raw values too
      TH1* hist = GetHist(pset);
      
      //calculate bin volume, only if necessary though .. 
      double val = hist->GetBinContent(bin);
      if(val) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        for(int i=0;i<hist->GetDimension();i++) {
          TAxis* ax = 0; if(i==0) ax = hist->GetXaxis(); else if(i==1) ax = hist->GetYaxis(); //FIXME: assumes 2D at most
          val /= ax->GetBinWidth(bb[i]);
        }
      }
      
      out += val;
    } else if(nomSet!=-1) { //can only interpolate when there's a valid parameter spacepoint
      //got here, must interpolate
      //loop over parameters, and use upSet and downSet to compute interpolated result
      TH1* hist = GetHist(nomSet);
      double nomVal = hist->GetBinContent(bin);
      double val = nomVal;

      RooFIter parItr(fParameters.fwdIterator());
      int i=-1;
      while(auto par = parItr.next() ) {
        i++;
        if(par->InheritsFrom( RooAbsCategory::Class() ) ) continue;
        if(upSet[i]==-1||downSet[i]==-1) continue; //no variation for this parameter (need at least two points)
        
        //now calculate the value based on interpolation between these two points 
        
        double y_down = GetHist( downSet[i] )->GetBinContent(bin);
        double x_down = fParameterSnapshots[downSet[i]][i];
        double y_up = GetHist( upSet[i] )->GetBinContent(bin);
        double x_up = fParameterSnapshots[upSet[i]][i];
        
        double tmpVal = ((y_up-y_down)/(x_up-x_down))*(((RooAbsReal*)par)->getVal() - x_down) + y_down;
        
        val += (tmpVal - nomVal);

        
      }
      
      if(val) { //divide by bin volume if it's necessary to
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        for(int i=0;i<hist->GetDimension();i++) {
          TAxis* ax = 0; if(i==0) ax = hist->GetXaxis(); else if(i==1) ax = hist->GetYaxis(); //FIXME: assumes 2D at most
          val /= ax->GetBinWidth(bb[i]);
        }
      }
      
      out += val;
    }
  }

  
  //multiply by all the norm factors
  RooFIter itr(fNormFactors.fwdIterator());
  while( RooAbsReal* arg = (RooAbsReal*)itr.next() ) out *= arg->getVal(); //NOTE: should we use _normSet? leads to issues if normfactor is a pdf...
  
  //and by the shape factors for this bin
  if(fBinsShapeFactors.find(bin)!=fBinsShapeFactors.end()) {
    for(auto& sfIdx : fBinsShapeFactors.at(bin)) {
      out *= ((RooAbsReal&)fShapeFactors[sfIdx]).getVal();
    }
  }
  
  return out;
  
}

TH1* TRooAbsH1::createOrAdjustHistogram(TH1* hist, bool noBinLabels) const {
  if(!hist) {
    hist = (TH1*)fDummyHist->Clone(GetName());
    hist->SetDirectory(0);
  }
  hist->Reset();
  
  const char* rname = GetRangeName();
  RooAbsLValue* obs[3] = {0,0,0}; 

  
  (*static_cast<TAttFill*>(hist)) = *this;
  (*static_cast<TAttLine*>(hist)) = *this;
  (*static_cast<TAttMarker*>(hist)) = *this;
  //propate axis titles, and bin labels in the case of categories
  switch(GetDimension()) {
    case 2: {
      RooAbsArg& arg = fObservables[1];
      RooAbsReal* argreal = dynamic_cast<RooAbsReal*>(&arg);
      if(argreal && strlen(argreal->getUnit()))  hist->GetYaxis()->SetTitle(Form("%s [%s]",arg.GetTitle(),argreal->getUnit()));
      else hist->GetYaxis()->SetTitle(arg.GetTitle());
      if(arg.InheritsFrom(RooCategory::Class())) {
      
      } else {
        obs[1] = dynamic_cast<RooAbsLValue*>(&arg);
        //rebin happens below
      }
    }
    case 1: {
      RooAbsArg& arg = fObservables[0];
      RooAbsReal* argreal = dynamic_cast<RooAbsReal*>(&arg);
      if(argreal && strlen(argreal->getUnit()))  hist->GetXaxis()->SetTitle(Form("%s [%s]",arg.GetTitle(),argreal->getUnit()));
      else hist->GetXaxis()->SetTitle(arg.GetTitle());
      if(arg.InheritsFrom(RooCategory::Class())) {
        RooCategory* cat = dynamic_cast<RooCategory*>(&arg);
        std::unique_ptr<TIterator> itr(cat->typeIterator());
        RooCatType* tt = 0; int binCount=1; int numBins=0;
        while((tt=(RooCatType*)itr->Next())) {
          if(cat->isStateInRange(tt->GetName(),rname)) numBins++;
        }
        hist->SetBins( numBins, -0.5, numBins-0.5 ); //FIXME : shouldn't rebin here :-(
        if(!noBinLabels) {
          itr->Reset();
          while((tt=(RooCatType*)itr->Next())) {
            if(cat->isStateInRange(tt->GetName(),rname)) hist->GetXaxis()->SetBinLabel(binCount++,tt->GetName());
          }
        }
      } else {
        obs[0] = dynamic_cast<RooAbsLValue*>(&arg);
        //rebin happens below
      }
    }
    break;
    case 0: {
      //simple number term. Just have one bin and label it with my title 
      hist->SetBins( 1, -0.5, 0.5 );
      
      if(!noBinLabels) hist->GetXaxis()->SetBinLabel(1,(dynamic_cast<const TNamed*>(this))->GetTitle());
    
    }
    
  }
  
  if(obs[1] && obs[0]) {
    //2D rebin 
    hist->SetBins( obs[0]->numBins(rname) , obs[0]->getBinningPtr(rname)->array() , obs[1]->numBins(rname) , obs[1]->getBinningPtr(rname)->array() );
  } else if(obs[0]) {
    //1D rebin
    hist->SetBins( obs[0]->numBins(rname) , obs[0]->getBinningPtr(rname)->array() );
  }
  
  return hist;
  
}


#include <limits>
TH1* TRooAbsH1::GetHistogram(const RooFitResult* r, bool includeErrors, TH1* histToFill) const {

  if(!histToFill) histToFill = fDrawHistogram;

  if(!histToFill) { 
    fDrawHistogram = (TH1*)fDummyHist->Clone(GetName());
    fDrawHistogram->SetDirectory(0);fDrawHistogram->Reset();
    histToFill = fDrawHistogram;
  }
  
  if(histToFill==fDrawHistogram) createOrAdjustHistogram(histToFill);
  
  fillHistogram(histToFill,r,includeErrors);
  
  return histToFill;
}

void TRooAbsH1::fillHistogram(TH1* histToFill, const RooFitResult* r, bool includeErrors) const {
  histToFill->Reset();
  //loop over bins and fill
  for(int i=1;i<=histToFill->GetNbinsX();i++) {
    double val = GetBinContent(i,r);
    if(val) histToFill->SetBinContent(i,val);
    if(includeErrors) {
      histToFill->SetBinError(i,GetBinError(i,r));
    }
  }
}

void TRooAbsH1::fillGraph(TGraph* graphToFill, const RooFitResult* r, bool includeErrors, int nPoints) const {
  if(nPoints>0) {
    TRooFitResult* myR = 0;
    if(includeErrors) {
      if(graphToFill->IsA() != TGraphErrors::Class()) {
        Error("fillGraph","Must receive TGraphErrors to fill errors. Will skip error filling");
        includeErrors = false;
      }
      if(r==0) {
        //default to propgating the uncertainties of all parameters
        RooArgSet* params = getParams(fObservables);
        myR = new TRooFitResult(*params); r = myR;
        delete params;
      }
    }
    //sample between min and max with nPoints
    graphToFill->Set(nPoints); //FIXME: remove points over nPoints
    //FIXME: handle discrete variables!
    double low = fDummyHist->GetXaxis()->GetBinLowEdge(1);
    double high = fDummyHist->GetXaxis()->GetBinLowEdge(fDummyHist->GetXaxis()->GetNbins()+1);
    RooAbsRealLValue* obs[3] = {0,0,0}; double tmpVals[3] = {0,0,0};
    if(fObservables.getSize()>0) {obs[0] = dynamic_cast<RooAbsRealLValue*>(&fObservables[0]); tmpVals[0]=obs[0]->getVal(); }
    double expec = expectedEvents(fObservables);
    for(int i=0;i<nPoints;i++) {
      double x = low + i*(high-low)/(nPoints-1);
      if(obs[0]) obs[0]->setVal( x );
      graphToFill->SetPoint(i, x, getVal(fObservables)*expec );
      if(includeErrors) {
        (static_cast<TGraphErrors*>(graphToFill))->SetPointError(i,0,getError(*r));
      }
    }
    for(int i=0;i<3;i++) if(obs[i]) obs[i]->setVal(tmpVals[i]);
    if(myR) delete myR;
  }
}


Double_t TRooH1::expectedEvents(const RooArgSet* nset) const { 
 if(nset==0/* || !dependsOn(*nset)*/) {
  //std::cout << " expected event 0 = " << getBinContent() << std::endl; 
  //return getBinContent(); //use the raw value for expected events
  return 1; //return 1 so that getBinContent is not messed up
 }
 double out = getNorm(nset);
 //std::cout << "expected events = " << out << std::endl;
 return out;
}



//these functions are needed by the RooBinIntegrator
std::list<Double_t>* TRooH1::binBoundaries(RooAbsRealLValue& obs, Double_t xlow, Double_t xhi) const {

  auto binning = obs.getBinningPtr(GetName()); //always use our own binning when integrating!
  std::list<Double_t>* out = new std::list<Double_t>;
  
  for(int i=0;i<binning->numBins();i++) {
    double binEdgeLow = binning->binLow(i);
    double binEdgeHigh = binning->binHigh(i);
    
    //if any overlap then we include
    if(binEdgeLow > xhi) break; //finished
    
    if(binEdgeHigh > xlow) {
      if(out->size()==0) out->push_back(binEdgeLow);
      out->push_back(binEdgeHigh);
    }
    
  }
  return out;
}

Bool_t TRooH1::isBinnedDistribution(const RooArgSet& obs) const {
  //if all obs are in the fObservables, then we are binnined
  RooFIter itr = obs.fwdIterator();
  while( RooAbsArg* arg = itr.next() ) {
    if(!fObservables.find(*arg)) return kFALSE;
  }
  return kTRUE;
}



//_____________________________________________________________________________
Bool_t TRooH1::syncNormalization(const RooArgSet* nset, Bool_t adjustProxies) const
{
  using namespace std;
  // Verify that the normalization integral cached with this PDF
  // is valid for given set of normalization observables
  //
  // If not, the cached normalization integral (if any) is deleted
  // and a new integral is constructed for use with 'nset'
  // Elements in 'nset' can be discrete and real, but must be lvalues
  //
  // For functions that declare to be self-normalized by overloading the
  // selfNormalized() function, a unit normalization is always constructed


//   cout << IsA()->GetName() << "::syncNormalization(" << GetName() << ") nset = " << nset << " = " << (nset?*nset:RooArgSet()) << endl ;

  _normSet = (RooArgSet*) nset ;
  //std::cout << "incoming = " << nset << std::endl;
  // Check if data sets are identical
  
  //for(int i=0; i < _normMgr._nsetCache.size();i++) {
  //  std::cout << "0cache nset (" << i << ") size=" << _normMgr._nsetCache[i].entries() << " index=" << _normMgr._nsetCache[i].index(nset,0,0) << std::endl;
  //}
  
  _normMgr._owner = 0; //dirty hack to stop autoCache method calling getObservables on me
  CacheElem* cache = (CacheElem*) _normMgr.getObj(nset) ;
  _normMgr._owner = (TRooH1*)this; //dirty hack to stop autoCache method calling getObservables on me
  
  
  //for(int i=0; i < _normMgr._nsetCache.size();i++) {
  //  std::cout << "cache nset (" << i << ") size=" << _normMgr._nsetCache[i].entries() << " index=" << _normMgr._nsetCache[i].index(nset,0,0) << std::endl;
  //}
  
  if (cache) {
    //check that variables integrated over matches
    //std::cout << "got cache " << cache->_norm->GetName() << " for (" << nset << ") : "; nset->Print();
    //std::cout << "value = " << cache->_norm->getVal() << std::endl;
    Bool_t nsetChanged = (_norm!=cache->_norm) ;
    _norm = cache->_norm ;


//      cout << "returning existing object " << _norm->GetName() << endl ;

    if (nsetChanged && adjustProxies) {
      // Update dataset pointers of proxies
      ((TRooH1*) this)->setProxyNormSet(nset) ;
    }
  
    return nsetChanged ;
  }
    
  // Update dataset pointers of proxies
  if (adjustProxies) {
    ((TRooH1*) this)->setProxyNormSet(nset) ;
  }
  
  //NOTE: an alternative to this 'depend on all observables' approach (where to auto extend uniformly in unknown observables)
  //would be to modify the unit normalization return below to be replaced by SELF VALUE
  //could use a RooFormulaVar for this, I guess, or a RooAddition with just ourself in the func list
  
  RooArgSet* depList = getObservables(nset); //(nset) ? new RooArgSet(*nset) : new RooArgSet;//WB integrate over all variables!! getObservables(nset) ;
  //depList->Print();

  if (_verboseEval>0) {
    if (!selfNormalized()) {
      cxcoutD(Tracing) << IsA()->GetName() << "::syncNormalization(" << GetName() 
	   << ") recreating normalization integral " << endl ;
      if (depList) depList->printStream(ccoutD(Tracing),kName|kValue|kArgs,kSingleLine) ; else ccoutD(Tracing) << "<none>" << endl ;
    } else {
      cxcoutD(Tracing) << IsA()->GetName() << "::syncNormalization(" << GetName() << ") selfNormalized, creating unit norm" << endl;
    }
  }

  // Destroy old normalization & create new
  if (selfNormalized()/* || !dependsOn(*depList)*/) {    
    TString ntitle(GetTitle()) ; ntitle.Append(" Unit Normalization") ;
    TString nname(GetName()) ; nname.Append("_UnitNorm") ;
    _norm = new RooRealVar(nname.Data(),ntitle.Data(),1) ;
  } else {    
    const char* nr = (_normRangeOverride.Length()>0 ? _normRangeOverride.Data() : (_normRange.Length()>0 ? _normRange.Data() : 0)) ;

//     cout << "RooAbsPdf::syncNormalization(" << GetName() << ") rangeName for normalization is " << (nr?nr:"<null>") << endl ;
    RooAbsReal* normInt = createIntegral(*depList,*getIntegratorConfig(),nr) ;
    normInt->getVal() ;
//     cout << "resulting normInt = " << normInt->GetName() << endl ;

    const char* cacheParamsStr = getStringAttribute("CACHEPARAMINT") ;
    if (cacheParamsStr && strlen(cacheParamsStr)) {
      
      RooArgSet* intParams = normInt->getVariables() ;
      
      RooNameSet cacheParamNames ;
      cacheParamNames.setNameList(cacheParamsStr) ;
      RooArgSet* cacheParams = cacheParamNames.select(*intParams) ;
      
      if (cacheParams->getSize()>0) {
	cxcoutD(Caching) << "RooAbsReal::createIntObj(" << GetName() << ") INFO: constructing " << cacheParams->getSize()
			 << "-dim value cache for integral over " << *depList << " as a function of " << *cacheParams << " in range " << (nr?nr:"<default>") <<  endl ;
	string name = Form("%s_CACHE_[%s]",normInt->GetName(),cacheParams->contentsString().c_str()) ;
	RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,*cacheParams) ;
	cachedIntegral->setInterpolationOrder(2) ;
	cachedIntegral->addOwnedComponents(*normInt) ;
	cachedIntegral->setCacheSource(kTRUE) ;
	if (normInt->operMode()==ADirty) {
	  cachedIntegral->setOperMode(ADirty) ;
	}
	normInt= cachedIntegral ;
      }
      
      delete cacheParams ;
      delete intParams ;
    }
    _norm = normInt ;    
  }
  
  // Register new normalization with manager (takes ownership)
  cache = new CacheElem(*_norm) ;
  _normMgr._owner = 0; //dirty hack to stop autoCache method calling getObservables on me
  _normMgr.setObj(nset,cache) ;
  _normMgr._owner = (TRooH1*)this; //dirty hack to stop autoCache method calling getObservables on me
  
//   cout << "making new object " << _norm->GetName() << endl ;

  delete depList ;
  return kTRUE ;
}

/*
Int_t TRooH1::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName) const {
  //for now, only worry about NormFactor depending on an observable that we are integrating on
  
  //we must end up copying to analVars the observables that a norm factor also depends on
  //for now we will do just 1D case
  
  auto integratingObs = fObservables.selectCommon(allVars);
  if(integratingObs->getSize()==0) { delete integratingObs; return 0; }
  RooFIter nf = fNormFactors.fwdIterator();
  RooAbsArg* arg; bool found(false);
  while( (arg = nf.next()) ) {
    if(arg->dependsOn(*integratingObs)) {
      found=true; //for now, if not found then fallback on integrator
      std::cout << " found= " << arg->GetName() << std::endl;
      analVars.add(*integratingObs); break; //for now just stop immediately ... could in future use the return code to say which normfactor is dependent
    }
  }
  
  
  delete integratingObs; return found;
  
  //note that if no factors depend on observables, roofit will just fall back on our declared BinIntegrator!
  
}
 
Double_t TRooH1::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const {

  //got here, so must have a normFactor that depends on observables
  //we will need to step through our bins, get our val and multiply it by the integrals of any dependent normfactor
  //remember to divide out the included norm factor value: FIXME: what if the normfactor is 0 at evaluation point, but nonzero in other parts of bin!?
  
  if(code==0) return getBinContent();
  
  std::cout << "got code " << code << std::endl;
  
  //FIXME: we assume 1D case for now!
  
  RooFIter nf = fNormFactors.fwdIterator();
  RooAbsReal* arg;
  RooArgList dependentNf;
  RooArgList dependentNfIntegrals;
  TString intRange = Form("%s_intRange",GetName()); //we will change this range to match the bin edges as we loop over bins
  while( (arg = (RooAbsReal*)nf.next()) ) {
    if(arg->dependsOn(fObservables)) {
      dependentNf.add(*arg);
      dependentNfIntegrals.addOwned( *arg->createIntegral( RooArgSet(fObservables) , intRange ) );
    }
  }
  
  RooAbsRealLValue* obs = dynamic_cast<RooAbsRealLValue*>(&fObservables[0]);
  
  //RooAbsBinning&
  const RooAbsBinning* obs_bins = obs->getBinningPtr(GetName());
  
  std::unique_ptr<TIterator> dnf(dependentNf.createIterator());
  std::unique_ptr<TIterator> dnfInt(dependentNfIntegrals.createIterator());
  
  double out(0.);
  for(int k=1;k<= (obs ? obs_bins->numBins() : 0);k++) {
    obs->setVal( obs_bins->binCenter(k-1) );
    if(!obs->inRange(rangeName)) continue;
    double binVal = getBinContent();
    obs->getBinning(intRange).setRange(obs_bins->binLow(k-1),obs_bins->binHigh(k-1));
    //divide out dependent normFactors
    dnf->Reset();dnfInt->Reset();
    while( (arg = (RooAbsReal*)dnf->Next()) ) {
      double oldVal = arg->getVal();
      double inte = ((RooAbsReal*)dnfInt->Next())->getVal();
      std::cout << arg->GetName() << " value in bin " << k << " obsVal=" << obs->getVal() <<" is " << oldVal << " integral = " << inte << std::endl;
      binVal /= arg->getVal();
      binVal *= inte;
      out += binVal;
    }
  }
  return out;

}

*/

#include "TVectorD.h"

///BORROWED THIS CODE FROM RooAbsReal
///But added dependencies on expectedEvents too!
//_____________________________________________________________________________
Double_t TRooAbsH1::getError(const RooFitResult& fr) const 
{
  // Calculate error on self by propagated errors on parameters with correlations as given by fit result
  // The linearly propagated error is calculated as follows
  //                                    T            
  // error(x) = F_a(x) * Corr(a,a') F_a'(x)
  //
  // where     F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result
  //       Corr(a,a') = the correlation matrix from the fit result
  //


  // Clone self for internal use
  RooAbsReal* cloneFunc = (RooAbsReal*) cloneTree() ;
  RooArgSet* errorParams = cloneFunc->getObservables(fr.floatParsFinal()) ;
  RooArgSet* nset = cloneFunc->getParameters(*errorParams) ;
  //remove const pars from nset ...
  
  //DONT NEED TO SNAP because we cloneTreed ... RooArgSet nsnap; nset->snapshot(nsnap);
  *nset = fr.constPars(); //also ensure any const parameters are set to their respective values 
  
  //nset->remove( fr.constPars(),false,true );
  auto constpars = nset->selectByAttrib("Constant",true); //this is more certain to catch the constant parameters and not normalize on them
  nset->remove(*constpars); delete constpars;
  
  
  // Make list of parameter instances of cloneFunc in order of error matrix
  RooArgList paramList ;
  const RooArgList& fpf = fr.floatParsFinal() ;
  std::vector<int> fpf_idx ;
  for (Int_t i=0 ; i<fpf.getSize() ; i++) {
    RooAbsArg* par = errorParams->find(fpf[i].GetName()) ;
    //if (par) {
    if(par && ((RooRealVar&)fpf[i]).getError()>1e-9) { //WB2017: added this line to stop tiny errors breaking things
      paramList.add(*par) ;
      fpf_idx.push_back(i) ;
    }
  }
  
  if(paramList.getSize()==0) {
    delete cloneFunc; delete errorParams; delete nset;
    return 0; //no error
  }

  //DONT NEED TO SNAP BECAUSE WE cloneTree'd! RooArgSet psnap;errorParams->snapshot(psnap); //save the current values
  *errorParams = fpf; //sets all param values to central values, including ones that had no error in floatParsFinal
  

  std::vector<Double_t> plusVar, minusVar ;    
  
  // Create vector of plus,minus variations for each parameter  
  TMatrixDSym V(paramList.getSize()==fr.floatParsFinal().getSize()?
		fr.covarianceMatrix():
		fr.reducedCovarianceMatrix(paramList)) ;
  
  for (Int_t ivar=0 ; ivar<paramList.getSize() ; ivar++) {
    
    RooRealVar& rrv = (RooRealVar&)fpf[fpf_idx[ivar]] ;
    
    Double_t cenVal = rrv.getVal() ;
    Double_t errVal = sqrt(V(ivar,ivar)) ;
    
    
    // Make Plus variation
    ((RooRealVar*)paramList.at(ivar))->setVal(cenVal+errVal) ;
    plusVar.push_back(cloneFunc->getVal(nset)*(dynamic_cast<RooAbsPdf*>(cloneFunc))->expectedEvents(nset)) ;
    
    // Make Minus variation
    ((RooRealVar*)paramList.at(ivar))->setVal(cenVal-errVal) ;
    minusVar.push_back(cloneFunc->getVal(nset)*(dynamic_cast<RooAbsPdf*>(cloneFunc))->expectedEvents(nset)) ;
    
    ((RooRealVar*)paramList.at(ivar))->setVal(cenVal) ;
  }
  
  TMatrixDSym C(paramList.getSize()) ;      
  std::vector<double> errVec(paramList.getSize()) ;
  for (int i=0 ; i<paramList.getSize() ; i++) {
    errVec[i] = sqrt(V(i,i)) ;
    for (int j=i ; j<paramList.getSize() ; j++) {
      C(i,j) = V(i,j)/sqrt(V(i,i)*V(j,j)) ;
      C(j,i) = C(i,j) ;
    }
  }
  
  // Make vector of variations
  TVectorD F(plusVar.size()) ;
  for (unsigned int j=0 ; j<plusVar.size() ; j++) {
    F[j] = (plusVar[j]-minusVar[j])/2 ;
  }
  
  //*errorParams = psnap; //puts all params back
  //*nset = nsnap;

  // Calculate error in linear approximation from variations and correlation coefficient
  Double_t sum = F*(C*F) ;

  delete cloneFunc ;
  delete errorParams ;
  delete nset ;

  return sqrt(sum);
}


//_____________________________________________________________________________
Double_t TRooH1::getValV(const RooArgSet* nset) const
{
  if(kUseAbsPdfValV) return RooAbsPdf::getValV(nset);
  ///THIS CODE IS COPIED FROM BUT SLIGHTLY MODIFIED VERSION OF RooAbsPdf::getValV
  ///DONE TO SUPPRESS WARNINGS ABOUT NEGATIVE VALUES
  
  // Return current value, normalizated by integrating over
  // the observables in 'nset'. If 'nset' is 0, the unnormalized value. 
  // is returned. All elements of 'nset' must be lvalues
  //
  // Unnormalized values are not cached
  // Doing so would be complicated as _norm->getVal() could
  // spoil the cache and interfere with returning the cached
  // return value. Since unnormalized calls are typically
  // done in integration calls, there is no performance hit.

  // Fast-track processing of clean-cache objects
  //   if (_operMode==AClean) {
  //     cout << "RooAbsPdf::getValV(" << this << "," << GetName() << ") CLEAN  value = " << _value << endl ;
  //     return _value ;
  //   }

  // Special handling of case without normalization set (used in numeric integration of pdfs)
  if (!nset) {
    RooArgSet* tmp = _normSet ;
    _normSet = 0 ;
    Double_t val = evaluate() ;
    _normSet = tmp ;
    Bool_t error = (TMath::IsNaN(val)) ? traceEvalPdf(val) : false; //allows negative and zero values

    if (error) {
//       raiseEvalError() ;
      return 0 ;
    }
    return val ;
  }


  // Process change in last data set used
  Bool_t nsetChanged(kFALSE) ;
  if (nset!=_normSet || _norm==0) {
    nsetChanged = syncNormalization(nset) ;
  }

  // Return value of object. Calculated if dirty, otherwise cached value is returned.
  if (isValueDirty() || nsetChanged || _norm->isValueDirty()) {

    // Evaluate numerator
    Double_t rawVal = evaluate() ;
    Bool_t error = (TMath::IsNaN(rawVal)) ? traceEvalPdf(rawVal) : false; //allows negative and zero values // Error checking and printing

    // Evaluate denominator
    Double_t normVal(_norm->getVal()) ;
    
    //add the missing bin, if its defined
    //if(fMissingBinProxy.absArg()) normVal += fMissingBinProxy;
    //if(fMissingBin) normVal += fMissingBin->getVal();
    
//     if (normVal<=0.) {
//       error=kTRUE ;
//       logEvalError("p.d.f normalization integral is zero or negative") ;  
//     }

    // Raise global error flag if problems occur
    if (error) {
//       raiseEvalError() ;
      _value = 0 ;
    } else {
      _value = rawVal / normVal ;
//       cout << "RooAbsPdf::getValV(" << GetName() << ") writing _value = " << rawVal << "/" << normVal << " = " << _value << endl ;
    }

    if(rawVal==0 && normVal==0) _value=1;
    if(kMustBePositive && _value < 0) _value=0;

    clearValueAndShapeDirty() ; //setValueDirty(kFALSE) ;
  } 

  return _value ;
}







void TRooAbsH1::Paint(Option_t*) {
    //Paint the histograms of the current pad
    
    //first ensure the last drawn histogram is appropriately styled
    if(fDrawHistograms.size()) {
      (*dynamic_cast<TAttFill*>(fDrawHistograms.back().hist)) = *this;
      (*dynamic_cast<TAttLine*>(fDrawHistograms.back().hist)) = *this;
      (*dynamic_cast<TAttMarker*>(fDrawHistograms.back().hist)) = *this;
      /*
      if(fDrawHistograms.back().hist->InheritsFrom(TH1::Class())) {
        // cant use this method unless we refill the hist TRooAbsH1::createOrAdjustHistogram( static_cast<TH1*>(fDrawHistograms.back().hist) );
        (*dynamic_cast<TAttFill*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttLine*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttMarker*>(fDrawHistograms.back().hist)) = *this;
      } else if(fDrawHistograms.back().hist->InheritsFrom(TGraph::Class())) {
        //FIXME: style the graph

      }
      */
    }
    
    
//     double currMax = -1e50; double currMin = 1e50;
//     std::vector<TH1*> hists;
/*
    for(auto& hist : fDrawHistograms) {
      if(hist.pad == gPad) {  
        if(hist.hist->InheritsFrom(TH1::Class())) {
          TRooAbsH1::fillHistogram(static_cast<TH1*>(hist.hist),hist.fr,true); //updates with current value
        } else if(hist.hist->InheritsFrom(TGraph::Class())) {
          TRooAbsH1::fillGraph(static_cast<TGraph*>(hist.hist),hist.fr,true); //updates with current value
        }
        //hist.hist->Paint(hist.opt); ..don't paint here because added histogram to primitives directly (above)
        
        ///FIXME: wanted a way to auto-adjust the frame limits based on histograms we are drawing
//         hists.push_back(hist.hist);
//         if(hist.hist->GetMaximum() > currMax) {
//           currMax = hist.hist->GetMaximum();
//           for(auto& h : hists) h->SetMaximum(currMax);
//         }
//         if(hist.hist->GetMinimum() < currMin) {
//           currMin = hist.hist->GetMinimum();
//           for(auto& h : hists) h->SetMinimum(currMin);
//         }
      }
    }
*/

//     if(!fDrawHistogram) GetHistogram(fDrawFitResult,true); 
//     else TRooAbsH1::fillHistogram(fDrawHistogram,fDrawFitResult,true); //updates with current values
//     fDrawHistogram->Paint(option); 
}

#include "TROOT.h"
#include "TPad.h"
void TRooAbsH1::Draw(Option_t *option)
{
  //Draw method taking just an option
  //option is used to construct a TRooFitResult that can be used to set parameters
  //constant at a given value
  //I.e. you can do: Draw("param=value") to draw this pdf at the given value

  //FIXME: should really remove from option any bits that got used successfully for constPars construction

   TRooAbsH1::Draw(option,TRooFitResult(option));
}

void TRooAbsH1::Draw(Option_t* option,const TRooFitResult& r) {
  //Main Draw method for TRooFit pdfs 
  //See the concrete implementations for more details:
  //    TRooH1D::Draw 
  //    TRooHStack::Draw 
  //    TRooHPdfStack::Draw 

  TString opt = option;
  opt.ToLower();
  
  TRooFitResult* r2 = 0;
  
  if(r.floatParsFinal().getSize()|| r.constPars().getSize()) {
    if(opt.Contains("init")) {
      //request to draw initial parameters instead of final
      r2 = new TRooFitResult(r.floatParsInit());
      opt.ReplaceAll("init","");
    } else {
      r2 = new TRooFitResult(r.floatParsFinal());
    }
    r2->setConstParList(r.constPars());
  }
  
     // Draw this hist
   // if option contains 'pdf' then we draw as a graph instead

   bool found(false);
   
   TObject* me = dynamic_cast<TObject*>(this);
   
   if (gPad) {
      if (!gPad->IsEditable()) gROOT->MakeDefCanvas();
      if (!opt.Contains("same")) {
         //the following statement is necessary in case one attempts to draw
         //a temporary histogram already in the current pad
         if (me->TestBit(kCanDelete)) gPad->GetListOfPrimitives()->Remove(me);
         gPad->Clear();
         
         //also delete any DrawnHistograms that matched this pad:
         auto itr = fDrawHistograms.begin();
         while( itr != fDrawHistograms.end() ) {
          if(itr->pad==gPad) {
            if(itr->hist!=itr->postHist) SafeDelete(itr->postHist);
            SafeDelete(itr->hist);
            SafeDelete(itr->fr);
            fDrawHistograms.erase(itr);
          } else {
            ++itr;
          }
         }
      } else {
        //check if I'm already in the list of primitives ... if so, we wont add me a second time
        if(gPad->GetListOfPrimitives()->FindObject(me)) {
          gPad->Modified(true);
          found = true;
        }
      }
   }
   if(!found) me->AppendPad(opt.Data()); //will create gPad
   
   if(gPad->IsEditable()) {
    fDrawHistograms.emplace_back( DrawnHistogram() );
    fDrawHistograms.back().pad = gPad;
    if(opt.Contains("pdf")) {
      TGraph* g = new TGraphErrors; //FIXME: at some point want to make with asymm errors
      g->SetName(GetName());g->SetTitle(GetTitle());
      fDrawHistograms.back().hist = g;
      TRooAbsH1::createOrAdjustHistogram( g->GetHistogram() );
      
      (*dynamic_cast<TAttFill*>(g)) = *this;
      (*dynamic_cast<TAttLine*>(g)) = *this;
      (*dynamic_cast<TAttMarker*>(g)) = *this;
      
      fillGraph(g,r2,opt.Contains("e"));
      
      if(fObservables.getSize()) {
        RooAbsArg& arg = fObservables[0];
        RooAbsReal* argreal = dynamic_cast<RooAbsReal*>(&arg);
        if(argreal && strlen(argreal->getUnit())) {
          g->GetHistogram()->GetXaxis()->SetTitle(Form("%s [%s]",arg.GetTitle(),argreal->getUnit()));
          g->GetHistogram()->GetYaxis()->SetTitle(Form("dN/d%s [%s^{-1}]",arg.GetTitle(),argreal->getUnit()));
        } else {
          g->GetHistogram()->GetXaxis()->SetTitle(arg.GetTitle());
          g->GetHistogram()->GetYaxis()->SetTitle(Form("dN/d%s",arg.GetTitle()));
        }
        
      }
      
      opt.ReplaceAll("pdf","");
      
      if(opt.Contains("e") && opt.Contains("l")) {
        //want to ensure line appears above error band, so draw put a copy in the posthist ..
        fDrawHistograms.back().postHist = g;
        fDrawHistograms.back().postHistOpt = "lx"; //draws as line without error bars
      }
      
    } else { 
      TH1* hist = TRooAbsH1::createOrAdjustHistogram( 0 );
      fDrawHistograms.back().hist = hist;
      fillHistogram( hist , r2, true);
      
      //if drawing with option "e3XXX" then will use that histogram as error bar histogram
      if(opt.Contains("e3")) {
        int fillType = TString(opt(opt.Index("e3")+1,opt.Length())).Atoi();
        if(fillType>=3000 && fillType<=3999 && hist->GetSumw2()->GetSum()) { //must have an error to draw an error bar hist
          TH1* errHist = (TH1*)hist->Clone(TString::Format("%s_error",hist->GetName()));
          errHist->SetFillStyle(fillType);errHist->SetMarkerStyle(0);errHist->SetFillColor(hist->GetLineColor());
          errHist->SetOption("e2same");
          fDrawHistograms.back().postHist = errHist;
          fDrawHistograms.back().postHistOpt = "e2same";
          opt.ReplaceAll(TString::Format("e%d",fillType),"");
          //since we are showing error bar, the main hist should only be drawn as a line
          opt += "hist";
        }
      }
      
      
    }
    
    fDrawHistograms.back().opt = opt; //have to store opt separately because not all object types we can SetOption on
    fDrawHistograms.back().fr = r2;
    gPad->GetListOfPrimitives()->Add( fDrawHistograms.back().hist , opt ); //adding histogram directly because cant figure out how to get clickable axis without it
    if(fDrawHistograms.back().postHist) gPad->GetListOfPrimitives()->Add( fDrawHistograms.back().postHist , fDrawHistograms.back().postHistOpt ); 
   }
  
  
  

}


Double_t TRooAbsH1::missingEvents() const  { 
  //Get value of the missingEvents bin
  //EXPERIMENTAL FEATURE: do not use

  return (fMissingBin) ? fMissingBin->getVal() : 0.; 
}
