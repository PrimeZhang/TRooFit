/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TRooFit/TRooAbsH1Fillable.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "RooAbsLValue.h"
#include "RooRealVar.h"
#include "RooProdPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooProduct.h"
#include "RooAddition.h"
#include "RooConstVar.h"

#include "RooDataSet.h"
#include "RooDataHist.h"

#include "RooNumIntConfig.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"

#include "RooCachedReal.h"

#include "RooBinning.h"

#include "TRooFit/TRooHStack.h"

#include <memory>

#include "TGraphErrors.h"

ClassImp(TRooAbsH1Fillable) 



TRooAbsH1Fillable::TRooAbsH1Fillable(RooAbsArg* me, const char* name, const char* title) : TRooAbsH1Fillable(me, name,title,RooArgList(),{},{},{}) {}
TRooAbsH1Fillable::TRooAbsH1Fillable(RooAbsArg* me, const char *name, const char *title,const RooArgList& observables, const int* bins, const double* min, const double* max ) : TRooAbsH1Fillable(me, name,title,observables,bins,min,max,{},0) {}
TRooAbsH1Fillable::TRooAbsH1Fillable(RooAbsArg* me, const char *name, const char *title,const RooArgList& observables, std::vector<int>&& bins, std::vector<double>&& min, std::vector<double>&& max ) : 
  TRooAbsH1Fillable(me, name,title,observables,&bins[0],&min[0],&max[0],{},0) {}
TRooAbsH1Fillable::TRooAbsH1Fillable(RooAbsArg* me, const char *name, const char *title, const RooArgList& observables, TH1* hist) :
    TRooAbsH1Fillable(me,name,title,observables,0,0,0,{},hist) {}
TRooAbsH1Fillable::TRooAbsH1Fillable(RooAbsArg* me, const char *name, const char *title, 
                        const RooArgList& observables, std::vector<int>&& bins, std::vector<const Double_t*>&& binEdges ) : TRooAbsH1Fillable(me,name,title,observables,&bins[0],0,0,std::move(binEdges),0) {}

TRooAbsH1Fillable::TRooAbsH1Fillable(RooAbsArg* me, const char *name, const char *title, const RooArgList& observables, const int* bins, const double* min, const double* max, std::vector<const Double_t*>&& binEdges, TH1* hist) :
   TRooAbsH1(observables,me),
   fParameters("!pars","pars",me),
   fValues("!vals","!vals",me)
   
{ 
  //Only experts should construct TRooHF1 directly. Please use derived classes (e.g. TRooHF1D)

  std::vector<int> tmpBins; std::vector<const Double_t*> tmpEdges;
  if(hist==0 && bins==0 && min==0 && binEdges.size()==0) {
    bins = &tmpBins[0];
    binEdges = tmpEdges;
    //take binning from the observables .. 
    for(int i=0;i<fObservables.getSize();i++) {
      if(fObservables[i].IsA() == RooRealVar::Class()) {
        RooAbsBinning& myBins = static_cast<RooRealVar&>(fObservables[i]).getBinning();
        tmpBins.push_back( myBins.numBins() );
        tmpEdges.push_back( myBins.array() );
      }
    }
  }
 
  //add binning to the continuous observables
  //also store the binnings and category sizes
  int j=0;
  for(int i=0;i<fObservables.getSize();i++) {
    if(fObservables[i].IsA() == RooRealVar::Class()) {
      if(hist) {
        if(hist->GetXaxis()->GetXbins()->GetArray()) {
          static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(hist->GetXaxis()->GetNbins(),hist->GetXaxis()->GetXbins()->GetArray()),name );
        } else {
          static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(hist->GetXaxis()->GetXmin(),hist->GetXaxis()->GetXmax(),hist->GetXaxis()->GetNbins()),name);
        }
      } else if(min==0) {
        static_cast<RooRealVar&>(fObservables[i]).setBinning(RooBinning(bins[j],binEdges[j]),name);
      } else {
        static_cast<RooRealVar&>(fObservables[i]).setBinning(RooUniformBinning(min[j],max[j],bins[j]),name);
      }
      j++;
    } else if(fObservables[i].IsA() == RooCategory::Class()) {
      RooCategory& cat = static_cast<RooCategory&>(fObservables[i]);
      std::unique_ptr<TIterator> itr( cat.typeIterator() );
      RooCatType* tt = 0;
      while( (tt = (RooCatType*)itr->Next()) ) {
        cat.addToRange(name,tt->GetName());
      }
    }
  }
  
//   //update axis in parent TH1
//   fNCells = 1;
//   switch(fObservables.getSize()) {
//     case 3: fZaxis.Set(bins[2],min[2],max[2]); fNCells *= (bins[2]+2);
//     case 2: fYaxis.Set(bins[1],min[1],max[1]); fNCells *= (bins[1]+2);
//     case 1: fXaxis.Set(bins[0],min[0],max[0]); fNCells *= (bins[0]+2);
//   }
//   fDimension=fObservables.getSize();
  
  if(hist) {
       //FIXME: should do checks on hist dimensions 
      fHists.push_back( (TH1*)hist->Clone(name) );
      if(!fHists[0]->GetSumw2()) fHists[0]->Sumw2();
      fHists[0]->SetDirectory(0);fHists[0]->Reset(); //clears it 
      //Add( hist ); //adds it, so that stat factors are created 
  } else {
  
    //create the default hist
    if(fObservables.getSize()==0) {
      fHists.push_back( new TH1D(name,title,1,-0.5,0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      dynamic_cast<RooAbsReal*>(me)->specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
    } else if(fObservables.getSize()==1) {
      if(dynamic_cast<TObject&>(fObservables[0]).InheritsFrom(RooAbsCategory::Class())) { 
        RooAbsCategory& cat = static_cast<RooAbsCategory&>(fObservables[0]);
        fHists.push_back( new TH1D(name,title,cat.numTypes(),-0.5,cat.numTypes()-0.5) );fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      } else {
        if(min==0) {
          fHists.push_back( new TH1D(name,title,bins[0],binEdges[0]) );
        } else {
          fHists.push_back( new TH1D(name,title,bins[0],min[0],max[0]) );
        }
        fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
      }
      dynamic_cast<RooAbsReal*>(me)->specialIntegratorConfig(kTRUE)->method1D().setLabel("RooBinIntegrator");
    } else if(fObservables.getSize()==2) {
      if(min==0) {
        fHists.push_back( new TH2D(name,title,bins[0],binEdges[0],bins[1],binEdges[1]) );
      } else {
        fHists.push_back( new TH2D(name,title,bins[0],min[0],max[0],bins[1],min[1],max[1]) );
      }
      fHists[0]->SetDirectory(0);fHists[0]->Sumw2();
    } else {
      std::cout << "not supported!" << std::endl;
    }
  }
 
  fParameterSnapshots.resize(1); //creates an empty vector
  fDummyHist = fHists[0];fDummyHist->GetXaxis()->SetTitle("");fDummyHist->GetYaxis()->SetTitle("");
  me->setAttribute("NeverConstant",true); //stops these objects being 'cached' away, because they rarely should be
  RooMsgService::instance().getStream(RooFit::INFO).removeTopic(RooFit::NumIntegration); //stop info message every time

} 


TRooAbsH1Fillable::TRooAbsH1Fillable(const TRooAbsH1Fillable& other, RooAbsArg* me) :  
   TRooAbsH1(other,me), kIsStandardParameterVariations(other.kIsStandardParameterVariations),
   fStandardUpSet(other.fStandardUpSet), fStandardDownSet(other.fStandardDownSet),
   fParameters(other.fParameters.GetName(),me,other.fParameters),
   fValues(other.fValues.GetName(),me,other.fValues),
   fHists(other.fHists),
   fFunctionalBinValues(other.fFunctionalBinValues),
   fParameterSnapshots(other.fParameterSnapshots),
   fInterpCode(other.fInterpCode),fObsInterpCode(other.fObsInterpCode)
{
  //Copy constructor
}




bool TRooAbsH1Fillable::addParameter( RooAbsArg& arg , int interpCode ) { 
  //Use this method to turn this TRooFit histogram into a function of the given parameter, arg.
  //All the previously filled values of the histogram will be assumed to correspond 
  //to the current value of the parameter 
  //
  //You can then change the value of the parameter and start to re-fill the histogram 
  //This will then make the histogram correspond to a coherent variation. 
  //
  //The interpCode determines the interpolation between parameter points .
  //See TRooAbsH1Fillable::setInterpCode for description of different options.
  //Default interpCode (4) is 6th order poly with log extrap
  //

  if(fParameters.find(arg)) return false; //already added
  
  
  
  fParameters.add(arg); fParameters.setName("pars"); fInterpCode.push_back(interpCode);
  if(fMissingBin) fMissingBin->addParameter(arg, interpCode);
  //add a clone to all existing paramsets too
  double val = (arg.InheritsFrom(RooAbsCategory::Class())) ? static_cast<RooAbsCategory&>(arg).getIndex() : static_cast<RooAbsReal&>(arg).getVal();
  for(auto& pars : fParameterSnapshots) {
    pars.push_back(val);
  }
  
  fStandardUpSet.clear(); fStandardDownSet.clear(); 
  fStandardUpSet.resize(fParameters.getSize(),-1); fStandardDownSet.resize(fParameters.getSize(),-1);
  
  //need to also tell all clients that we have a new parameter to depend on
  TIterator* citer(dynamic_cast<RooAbsArg*>(this)->clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->addServer(arg);client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}



Bool_t TRooAbsH1Fillable::Add(const TH1* h1 , Double_t c1, RooRealVar* parVar, double parVal) {
  //Add a histogram to this TRooAbsH1Fillable, i.e. fill the content of h1 into this TRooAbsH1Fillable
  //includes the optional scaling factor c1

  if(parVar) {
    if(!fParameters.find(*parVar)) {
      parVar->setVal(0);
      addParameter(*parVar);
    }
    double tmpVal = parVar->getVal();
    parVar->setVal(parVal);
    Bool_t out = Add(h1,c1);
    parVar->setVal(tmpVal);
    return out;
  }

  int pset = getOrCreateParamSet();
  bool out = fHists[pset]->Add(h1,c1);
  
  if(out && pset==0) { //add succeeded, and was adding to 'nominal' set, so adjust stat factors
    for(int i=1;i<=h1->GetNbinsX();i++) {
      for(int j=1;j<=h1->GetNbinsY();j++) {
        for(int k=1;k<=h1->GetNbinsZ();k++) {
          int bin = h1->GetBin(i,j,k);
          if(!h1->GetBinError(bin)) continue; //don't need to adjust if there was no error
          RooRealVar* statFactor = getStatFactor(bin); //first try without creating 
          if(!statFactor) { 
            statFactor = getStatFactor(bin, true);  //automatically sets sumw and sumw2 for us when creating a new statFactor
          } else {
            //update the sumw and sumw2 attribute of the stat factor
            statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() + h1->GetBinContent(bin)*c1)));
            statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() + pow(h1->GetBinError(bin)*c1,2))));
            //will also set the error to sqrt(sumw2)/sumw
            statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
            if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
          }
        }
      }
    }
  }
  return out;
}

Bool_t TRooAbsH1Fillable::Add(const TH1* h1 , Double_t c1, const char* parVar, double parVal) {
  RooRealVar* par = dynamic_cast<RooRealVar*>(fParameters.find(parVar));
  if(!par) {
    Error("Add","%s not found, please addParameter this parameter first",parVar);
    return kFALSE;
  }
  return Add(h1,c1,par,parVal);
}

Bool_t TRooAbsH1Fillable::Add( RooAbsReal& val ) {
  //adding a function is like filling every bin with it
  
  
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
    
  fFunctionalBinValues[-1].push_back(fValues.index(&val)); 
  
  //if the function depends on any of our observables, we will stop using binwise integration!
  //because we can no longer guarantee the function is flat across a given bin
  if(val.dependsOn(fObservables)){
    Info("Add","Disabling binwise integration for %s because %s depends on observables",GetName(),val.GetName());
    dynamic_cast<RooAbsReal*>(this)->specialIntegratorConfig(kTRUE)->method1D().setLabel("RooIntegrator1D");
    resetNormMgr();
  }
  return 0;
  
}





void TRooAbsH1Fillable::Scale( double x) {
  //first adjust any stat factors ...
  for(int i=1;i<=fHists[0]->GetNbinsX();i++) {
    for(int j=1;j<=fHists[0]->GetNbinsY();j++) {
      for(int k=1;k<=fHists[0]->GetNbinsZ();k++) {
        int bin = fHists[0]->GetBin(i,j,k);
        if(!fHists[0]->GetBinError(bin)) continue; //don't need to adjust if there was no error
        RooRealVar* statFactor = getStatFactor(bin); //first try without creating 
        if(!statFactor) continue; 
        //update the sumw and sumw2 attribute of the stat factor
        statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() - fHists[0]->GetBinContent(bin) + fHists[0]->GetBinContent(bin)*x)));
        statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() - pow(fHists[0]->GetBinError(bin),2) + pow(fHists[0]->GetBinError(bin)*x,2))));
        //will also set the error to sqrt(sumw2)/sumw
        statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
        if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
      }
    }
  }

  for(auto hist : fHists) hist->Scale(x); 
}

Int_t TRooAbsH1Fillable::Fill( double x , double w, RooRealVar* parVar, double parVal ) {
  //The usual histogram Fill method
  //This method will trigger the automatic creation of parameters (as necessary) 
  // to represent the statistical uncertainty in the filled bin 

  if(parVar) {
    if(!fParameters.find(*parVar)) {
      parVar->setVal(0);
      addParameter(*parVar);
    }
    double tmpVal = parVar->getVal();
    parVar->setVal(parVal);
    Int_t out = Fill(x,w);
    parVar->setVal(tmpVal);
    return out;
  }

  int pset = getOrCreateParamSet();
  
  int bin = (fObservables.getSize()==0) ? 1 : FindFixBin(x);
  if(fObservables.getSize()==0) { w = x; x = 0; } //in the counting-mode, the x variable is always "0"
  
  //only create stat factors when filling the 'nominal' histogram
  if(pset==0) {
    RooRealVar* statFactor = getStatFactor(bin, true);
    //update the sumw and sumw2 attribute of the stat factor
    statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() + w)));
    statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() + w*w)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    
  }
  

  
  
  return fHists[pset]->Fill(x,w);
  
  //FIXME: propagate changes to transFactor if there is one!
  
}

Int_t TRooAbsH1Fillable::Fill( double x , double w, const char* varPar, double varVal) {
  RooRealVar* par = dynamic_cast<RooRealVar*>(fParameters.find(varPar));
  if(!par) {
    Error("Fill","%s not found, please addParameter this parameter first",varPar);
    return kFALSE;
  }
  return Fill( x , w, par, varVal );
}

Int_t TRooAbsH1Fillable::Fill( const char* name , double w,  RooRealVar* parVar, double parVal ) {
  //Same as above, but can use name of Category type
  
  if(parVar) {
    if(!fParameters.find(*parVar)) {
      parVar->setVal(0);
      addParameter(*parVar);
    }
    double tmpVal = parVar->getVal();
    parVar->setVal(parVal);
    Int_t out = Fill(name,w);
    parVar->setVal(tmpVal);
    return out;
  }
  
  if(GetDimension()==0) return Fill(0.,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("Fill","%s is not a category, cannot fill",fObservables[0].GetName());
    return -1;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("Fill","%s unknown label in %s",name,fObservables[0].GetName());
    return -1;
  }
  return Fill( type->getVal() , w );
  
}

  
Int_t TRooAbsH1Fillable::Fill( Double_t x, RooAbsReal& val ) {
  //Fills (i.e. adds) a function to bin at x value, 
  if(fValues.index(&val)==-1) fValues.add(val);

  getOrCreateParamSet(); //do this to create a paramSet at the current state
  
  int bin = (fObservables.getSize()==0) ? -1 : FindFixBin(x);
  
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  return fValues.index(&val);
  
}





Int_t TRooAbsH1Fillable::getOrCreateParamSet() {
  //Internal method used when updating the content of the TRooAbsH1Fillable
  //e.g. in SetBinContent, Fill, SetBinError, etc

  me()->setValueDirty();
  //we have to dirty up ALL clients, not just those who have said they are value clients
  //integrals don't think of themselves as value clients because they think they integrate out changes in our value
  //i.e. they assume the only way a function can change value is if the servers change values
  //and so the only way THEY can change value is if the non-integrated servers change value
  
  TIterator* citer(me()->clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  //FIXME: I think we should reset (or at least sterilize) the _normMgr if this is RooAbsPdf too
  resetNormMgr();

  int pset = getParamSet();
  
  if(pset==-1) { //need to create a new hist, clone the "nominal" hist
    std::vector<double> parVals;
    //get the current paramter values
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      if(par->InheritsFrom( RooAbsCategory::Class() )) {
        parVals.push_back( ((RooAbsCategory*)par)->getIndex() );
      } else {
        parVals.push_back( ((RooAbsReal*)par)->getVal() );
      }
    }
    fParameterSnapshots.push_back(parVals);
    fHists.push_back( (TH1*)fHists[0]->Clone( Form("%s_variation%d",GetName(),int(fParameterSnapshots.size()))) ); 
    fHists.back()->SetDirectory(0);
    fHists.back()->Reset();
    pset = fParameterSnapshots.size()-1;
    
    //check for 'standard' parameter snapshots 
    //i.e. up to 2 snapshots per parameter, either side of the nominal (0th) snapshot
    fStandardUpSet.clear(); fStandardDownSet.clear(); 
    fStandardUpSet.resize(parVals.size(),-1); fStandardDownSet.resize(parVals.size(),-1);
    kIsStandardParameterVariations=true;
    for(uint parNum = 0;parNum<parVals.size();parNum++) {
      for(uint i=0;i<fParameterSnapshots.size();i++) {
        if(fabs(fParameterSnapshots[i][parNum] - fParameterSnapshots[0][parNum]) < 1e-9) continue; //is not a variation of parNum'th parameter 
        if(fStandardUpSet[parNum]==-1) fStandardUpSet[parNum]=i;
        else if(fStandardDownSet[parNum]==-1) {
          if(fParameterSnapshots[fStandardUpSet[parNum]][parNum] > fParameterSnapshots[0][parNum] && 
             fParameterSnapshots[i][parNum] < fParameterSnapshots[0][parNum]) {
            //is standard 
            fStandardDownSet[parNum] = i; 
          } else if(fParameterSnapshots[fStandardUpSet[parNum]][parNum] < fParameterSnapshots[0][parNum] && 
             fParameterSnapshots[i][parNum] > fParameterSnapshots[0][parNum]) {
            //standard but flipped order ..
            fStandardDownSet[parNum] = fStandardUpSet[parNum];
            fStandardUpSet[parNum]=i;
          } else {
            kIsStandardParameterVariations=false;
          }
        } else {
          kIsStandardParameterVariations=false;
        }
      }
    }
    if(!kIsStandardParameterVariations) {
      fStandardUpSet.clear(); fStandardDownSet.clear(); 
      fStandardUpSet.resize(parVals.size(),-1); fStandardDownSet.resize(parVals.size(),-1);
    }
    
    
  }
  return pset;
}

bool TRooAbsH1Fillable::setInterpCode(const char* parName, int code) {
  //Set interpolation code for a given parameter or observable
  //
  //Observables:
  // 0 = binned (default behaviour) 
  // 1 = linear interpolation between each bin 
  //
  //Parameters:
  // 0 = piecewise linear 
  // 2 = 6th order polynominal with log extrapolation (should match code 4, but this implemented differently)
  // 3 = 6th order polynominal with linear extrapolation (Like HistFactory::PiecewiseInterpolation's code 4)
  // 4 = 6th order polynominal with log extrapolation (Like HistFactory::FlexibleInterpVar's code 4)
  //
  //Note that in all cases, if only one variation (parameter space point) is provided for the given parameter
  //then straightforward linear interpolation is used. 
  //
  //Returns true on success


  int idx = fParameters.index(parName);
  if(idx==-1) {
    //check observables 
    idx = fObservables.index(parName);
    if(idx==-1) return false;
    if(code==0 && (fObsInterpCode&(1<<idx))) fObsInterpCode -= (1<<idx);
    else if( (fObsInterpCode&(1<<idx)) ==0) fObsInterpCode += (1<<idx);
  } else {
    fInterpCode[idx] = code;
  }
  
  //make everything dirty
  me()->setValueDirty();
  TIterator* citer(me()->clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  
  return true;
}

bool TRooAbsH1Fillable::setInterpCode(const RooAbsArg& arg, int code) {
  //Same as above, but can pass the actual argument 
  //
  return setInterpCode(arg.GetName(),code);
}

void TRooAbsH1Fillable::SetBinContent( int bin, double val, RooRealVar* parVar, double parVal ) {
  //Set the contents of a given bin

  if(parVar) {
    if(!fParameters.find(*parVar)) {
      parVar->setVal(0);
      addParameter(*parVar);
    }
    double tmpVal = parVar->getVal();
    parVar->setVal(parVal);
    SetBinContent(bin,val);
    parVar->setVal(tmpVal);
    return;
  }

  int pset = getOrCreateParamSet();
  //update the statFactor's sumw, if necessary
  if(pset==0 && fHists[pset]->GetBinContent(bin)) {
    RooRealVar* statFactor = getStatFactor(bin);
    if(statFactor) {
      statFactor->setStringAttribute("sumw",Form("%e",(TString(statFactor->getStringAttribute("sumw")).Atof() - fHists[pset]->GetBinContent(bin) + val)));
      //will also set the error to sqrt(sumw2)/sumw
      statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
      if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    }
  }
  fHists[pset]->SetBinContent(bin,val);
  //FIXME: propagate changes to transFactor if there is one!
}

void TRooAbsH1Fillable::SetBinContent( const char* name , double w, RooRealVar* parVar, double parVal ) {
  //Set the contents of a given bin 
  //The first observable of this TRooAbsH1Fillable must be a RooCategory

   if(parVar) {
    if(!fParameters.find(*parVar)) {
      parVar->setVal(0);
      addParameter(*parVar);
    }
    double tmpVal = parVar->getVal();
    parVar->setVal(parVal);
    SetBinContent(name,w);
    parVar->setVal(tmpVal);
    return;
  }

  //first observable must be a category
  if(GetDimension()==0) SetBinContent(1,w);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("SetBinContent","%s is not a category, cannot fill",fObservables[0].GetName());
    return;
  }
  auto type = cat->lookupType(name);
  if(!type) {
    Error("SetBinContent","%s unknown label in %s",name,fObservables[0].GetName());
    return;
  }
  SetBinContent( type->getVal() + 1 , w );
  
}

void TRooAbsH1Fillable::SetBinContent(  int bin, double val, const char* varPar, double varVal) {
  RooRealVar* par = dynamic_cast<RooRealVar*>(fParameters.find(varPar));
  if(!par) {
    Error("SetBinContent","%s not found, please addParameter this parameter first",varPar);
    return;
  }
  SetBinContent( bin , val, par, varVal );
}

void TRooAbsH1Fillable::SetBinContent( int bin, RooAbsReal& val ) {
  //Sets the bin content equal to a function value 
  
  SetBinContent(bin,0.); //clears existing content 
  
  if(fValues.index(&val)==-1) fValues.add(val);
  if(fObservables.getSize()==0) { bin = -1; } 
  
  fFunctionalBinValues[bin].clear(); //removes existing values 
  fFunctionalBinValues[bin].push_back(fValues.index(&val)); //FIXME: add checks on validity of bin!
  
}



void TRooAbsH1Fillable::SetBinError( int bin, double error ) {
  //Set the error of the given bin
  //If a statFactor for the bin does not already exist, it will be created
  //if error is 0, the statFactor will be removed, and deleted if necessary 

  int pset = getOrCreateParamSet();
  
  if(pset==0) {
    if(error==0) {
      RooRealVar* statFactor = getStatFactor(bin,false);
      if(!statFactor) {
        //no stat factor existing, ok, just update fHists to be sure and exit 
        fHists[pset]->SetBinError(bin,error);
        return;
      }
    }
  
    RooRealVar* statFactor = getStatFactor(bin,true);
    //update the sumw2 attribute of the stat factor ... 
    //the factor might be shared if its in a stack, so must subtract old error and add new one
    statFactor->setStringAttribute("sumw2",Form("%e",(TString(statFactor->getStringAttribute("sumw2")).Atof() - pow(fHists[pset]->GetBinError(bin),2) + error*error)));
    //will also set the error to sqrt(sumw2)/sumw
    statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
    if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    
    if(error==0) {
      //remove from shape factors ...
      fBinsShapeFactors[bin].erase(std::remove(fBinsShapeFactors[bin].begin(), fBinsShapeFactors[bin].end(), fShapeFactors.index(statFactor)), fBinsShapeFactors[bin].end());
      fShapeFactors.remove(*statFactor);
      if(fShapeFactors.getSize()==0) fShapeFactors.setName("!shapeFactors");
      fStatFactors.remove(*statFactor); //will cause deletion
      if(fStatFactors.getSize()==0) fStatFactors.setName("!statFactors");
    }
    
  } else {
    Warning("SetBinError","Bin errors only used when in nominal histogram");
  }
  
  fHists[pset]->SetBinError(bin,error);
  
}


Int_t TRooAbsH1Fillable::getParamSet() const {
  //Returns the ID of the current parameter spacepoint 
  //Or if the state of the parameters is an unknown point
  //then this method will return -1.

  if(fParameters.getSize()==0) return 0;
  
  //compare parameter values up to a certain 'precision' for equality
  int i=0;
  for(auto& parVals : fParameterSnapshots) {
    bool match(true);
    
    uint j=0;
    RooFIter parItr(fParameters.fwdIterator());
    while(auto par = parItr.next() ) {
      RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
      double val = 0;
      if(cat) {
        val = cat->getIndex();
      } else {
        val = static_cast<RooAbsReal*>(par)->getVal();
      }
      if( fabs(val - parVals[j]) > 1e-9 ) {match=false;break;}
      j++;
    }
    if(match) return i;
    i++;
  }
  
  return -1;
}


const std::vector<double>& TRooAbsH1Fillable::GetParamSet(int idx) const { 
  //Return the values of the parameters corresponding to paramSet = idx
  //The order of the parameters can be seen through the Print method 
  
  return fParameterSnapshots[idx]; 
}





//these functions are needed by the RooBinIntegrator
std::list<Double_t>* TRooAbsH1Fillable::binBoundaries(RooAbsRealLValue& obs, Double_t xlow, Double_t xhi) const {

  auto binning = obs.getBinningPtr(GetName()); //always use our own binning when integrating!
  std::list<Double_t>* out = new std::list<Double_t>;
  
  for(int i=0;i<binning->numBins();i++) {
    double binEdgeLow = binning->binLow(i);
    double binEdgeHigh = binning->binHigh(i);
    
    //if any overlap then we include
    if(binEdgeLow > xhi) break; //finished
    
    if(binEdgeHigh > xlow) {
      if(out->size()==0) out->push_back(binEdgeLow);
      out->push_back(binEdgeHigh);
    }
    
  }
  return out;
}

Bool_t TRooAbsH1Fillable::isBinnedDistribution(const RooArgSet& obs) const {
  //if all obs are in the fObservables, then we are binnined
  RooFIter itr = obs.fwdIterator();
  while( RooAbsArg* arg = itr.next() ) {
    if(!fObservables.find(*arg)) return kFALSE;
  }
  //if any of the global functions depend on our observables, we are also not binned ...
  auto&& fIter1 = fFunctionalBinValues.find(-1);
  if(fIter1!=fFunctionalBinValues.end()) {
    for(auto& vals : fIter1->second) {
      if(static_cast<RooAbsReal&>(fValues[vals]).dependsOn(fObservables)) return kFALSE;
    }
  }
  return kTRUE;
}




Double_t TRooAbsH1Fillable::evaluateImpl(bool divideByBinWidth) const 
{
  //The main roofit evaluation method. Users should not call this directly 
  //It is computing the pdf value (the probability density) 

//std::cout << "rangeName = " << GetRangeName() << " "; fObservables.Print("v"); 

  
  if(fBlindRangeName.Length()) {
    RooFIter obsItr(fObservables.fwdIterator());
    while(auto obs = obsItr.next() ) {
      if(obs->inRange(fBlindRangeName)) {
        if(kMustBePositive && 0 < fFloorValue) return fFloorValue;
        return 0;
      }
    }
  }
  
  int bin = getBin(GetName()); //forcefully use OUR binning 

  double out = 0;

    //loop over parameter snapshots, assessing which sets are valid (discrete params must match exactly)
    //if we find an exact match, we go with that
    
    //goal is that for each parameter to obtain the spacepoint IDs for the two closest valid spacepoints
    
    std::vector<int>& upSet = fStandardUpSet; //(fParameters.getSize(),-1); 
    std::vector<int>& downSet= fStandardDownSet; //(fParameters.getSize(),-1); 
    int nomSet = -1;
    
    int pset=-1;
    if(fParameters.getSize()==0) { //always use nominal if we are the denominator
      pset=0;
    } else {
    
      if(kIsStandardParameterVariations) {
      
        nomSet = 0;
      
      } else {
    
        int i=0;
        std::vector<int> setUp;std::vector<int> setDown; //get filled with parameter indices that should get set to up/down
        std::fill(fStandardUpSet.begin(),fStandardUpSet.end(),-1);std::fill(fStandardDownSet.begin(),fStandardDownSet.end(),-1);
        for(auto& parVals : fParameterSnapshots) {
          bool match(true); bool invalid(false);
          RooFIter parItr(fParameters.fwdIterator());
          int j=0; 
          setUp.clear();setDown.clear();
          while(auto par = parItr.next() ) {
            
            RooAbsCategory* cat = dynamic_cast<RooAbsCategory*>(par);
            if(cat) {
              if( cat->getIndex() != int(parVals[j]+0.5) ) {
                match=false;invalid=true;break;
              }
            } else {
              //record if this is up/down/nom variation for this parameter
              double parVal = ((RooAbsReal*)par)->getVal();
              double parDiff = fabs(parVal - parVals[j]);
              if(parDiff > 1e-9) {
                match=false;
                if(nomSet==-1) continue; //don't use the nomSet as our up-vs-down set 
                //check parVals[j] is different to fParameterSnapshots[nomSet][j] ... i.e. that this is a variation for parameter j
                if(fabs(parVals[j]-fParameterSnapshots[nomSet][j])<1e-9) continue;
                
                if(upSet[j]==-1) setUp.push_back(j); //the first variation we found
                else if(fInterpCode[j]==0) {
                  //special case for piecewise linear 
                  
                  if(downSet[j]==-1) {
                    double relativeValPos = (parVal - fParameterSnapshots[nomSet][j])/(fParameterSnapshots[upSet[j]][j]-fParameterSnapshots[nomSet][j]);
                    
                    double relativeCurrPos = (parVals[j] - fParameterSnapshots[nomSet][j])/(fParameterSnapshots[upSet[j]][j]-fParameterSnapshots[nomSet][j]);
                  
                    if((relativeValPos > 1 && relativeCurrPos > 0) || (relativeValPos>0 && relativeCurrPos>0 && relativeCurrPos<relativeValPos)) {
                      setDown.push_back(j); //add down 
                    } else if((relativeValPos < 0 && relativeCurrPos < 1) || (relativeValPos>0 && relativeCurrPos<1 && relativeCurrPos>relativeValPos)) {
                      setUp.push_back(j); //replace up
                    }
                  } else {
                    //upSet and downSet must be closer to actual val than nomVal ...
                    double relativeValPos = (parVal - fParameterSnapshots[downSet[j]][j])/(fParameterSnapshots[upSet[j]][j]-fParameterSnapshots[downSet[j]][j]);
                    double relativeCurrPos = (parVals[j] - fParameterSnapshots[downSet[j]][j])/(fParameterSnapshots[upSet[j]][j]-fParameterSnapshots[downSet[j]][j]);
                    
                    if( (relativeValPos < 0 && relativeCurrPos < 1) || (relativeValPos < 1 && relativeCurrPos < 1 && relativeValPos < relativeCurrPos) ) {
                      setUp.push_back(j); //replace up 
                    } else if(relativeValPos < 1 && relativeValPos > 0 && relativeCurrPos > 0 && relativeCurrPos < relativeValPos) {
                      setDown.push_back(j); //replace down
                    }
                    
                  }
                }
                else if(downSet[j]==-1) setDown.push_back(j);
                
                
              }
            }
            j++;
          }
          if(match) {
            pset=i; 
            break; //can just stop right now, found a perfect match
          }
          if(!invalid) { //if snapshot featured a variation up or down, store that
            if(nomSet==-1) nomSet=i; //the first valid set is used as the nom set
            //signal which parameters this snapshot is a valid variation for
            for(auto& j : setUp) upSet[j]=i;
            for(auto& j : setDown) downSet[j]=i;
          }
          i++;
        }
       }
    }
    
    //add the functional bin values
    double binVol = 1.; bool gotBinVol(false);
    double val(0);
    auto&& fIter1 = fFunctionalBinValues.find(-1);
    if(fIter1!=fFunctionalBinValues.end()) {
      
      if(divideByBinWidth && !gotBinVol) { gotBinVol=true; binVol /= GetBinVolume(bin); }
      for(auto& vals : fIter1->second) {
        //warning: dont want to use getVal(_normSet) because we've added a pdf, not necessarily added a NORMALIZED pdf
        RooAbsReal& func = static_cast<RooAbsReal&>(fValues[vals]);
        val = func.getVal();
        if( (divideByBinWidth) && !func.InheritsFrom(RooAbsPdf::Class()) && !func.getAttribute("isDensity") ) val *= binVol; //if function is a pdf, we assume it is already a density!
        out += val;
      }
    }
    auto&& fIter2 = fFunctionalBinValues.find(bin);
    if(fIter2 != fFunctionalBinValues.end()) {
      if(divideByBinWidth && !gotBinVol) { gotBinVol=true; binVol /= GetBinVolume(bin); }
      for(auto& vals : fIter2->second) {
        RooAbsReal& func = static_cast<RooAbsReal&>(fValues[vals]);
        val = func.getVal();
        if( (divideByBinWidth) && !func.InheritsFrom(RooAbsPdf::Class()) && !func.getAttribute("isDensity") ) val *= binVol; //should we divide these by bin volume!!?? perhaps only if is function of observables
        out += val;
      }
    }
    
    

    if(pset!=-1) {
      //add the raw values too
      TH1* hist = fHists[pset];
      
      //calculate bin volume, only if necessary though .. 
      val = 0;
      if(fObsInterpCode) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        switch(hist->GetDimension()) {
          case 1: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] )); break;
          case 2: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ) ); break;
          case 3: val = hist->Interpolate((fObsInterpCode&1)? static_cast<RooAbsReal&>(fObservables[0]).getVal() : hist->GetXaxis()->GetBinCenter( bb[0] ), 
                                     (fObsInterpCode&2)? static_cast<RooAbsReal&>(fObservables[1]).getVal() : hist->GetYaxis()->GetBinCenter( bb[1] ),
                                     (fObsInterpCode&4)? static_cast<RooAbsReal&>(fObservables[2]).getVal() : hist->GetYaxis()->GetBinCenter( bb[2] ) ); break;
        }
      } else {
         val = hist->GetBinContent(bin);
      }
      if(divideByBinWidth && val) {
        if(!gotBinVol) { gotBinVol=true; binVol /= GetBinVolume(bin); }
        val *= binVol;
      }
      
      out += val;
    } else if(nomSet!=-1) { //can only interpolate when there's a valid parameter spacepoint
       //std::cout << "nomSet = " << nomSet << std::endl;
       //std::cout << "upSet = "; for(auto s : fStandardUpSet) std::cout << s << ":"; std::cout << std::endl;
       //std::cout << "downSet = "; for(auto s : fStandardDownSet) std::cout << s << ":"; std::cout<<std::endl;
      //got here, must interpolate
      //loop over parameters, and use upSet and downSet to compute interpolated result
      TH1* hist = fHists[nomSet];
      double nomVal(0);
      double interpCoords[3];
      if(fObsInterpCode) {
        int bb[3]; hist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
        for(int i=0;i<hist->GetDimension();i++) {
          interpCoords[i] = (fObsInterpCode&(1<<i)) ? static_cast<RooAbsReal&>(fObservables[i]).getVal() : hist->GetXaxis()->GetBinCenter( bb[i] );
        }
        switch(hist->GetDimension()) {
          case 1: nomVal = hist->Interpolate(interpCoords[0]); break;
          case 2: nomVal = hist->Interpolate(interpCoords[0], interpCoords[1]); break;
          case 3: nomVal = hist->Interpolate(interpCoords[0], interpCoords[1], interpCoords[2]); break;
        }
      } else {
        nomVal = hist->GetBinContent(bin);
      }
      val = nomVal;

      RooFIter parItr(fParameters.fwdIterator());
      int i=-1;
      RooAbsArg* par = 0;
      while( (par = parItr.next()) ) {
        i++;
        
        int upIdx = upSet[i]; //the paramSet corresponding to one nearest fluctuation 
        
        if(!kIsStandardParameterVariations && par->InheritsFrom( RooAbsCategory::Class() ) ) continue;
        if(upIdx==-1) continue; //no variation for this parameter (need at least a point)
        
        double x_val = ((RooAbsReal*)par)->getVal();
        
        int downIdx = downSet[i]; //the paramSet that corresponds to the other nearest fluctuation (may be =-1 if no additional fluctuation)

        double x_up = fParameterSnapshots[upIdx][i];
        double x_down = (downIdx!=-1) ? fParameterSnapshots[downIdx][i] : fParameterSnapshots[nomSet][i];

        
        if(fInterpCode[i]==0 && downIdx!=-1) {
          //when using piecewise interpolation, we may prefer nominal to one of up or down, if nominal is "closer" 
          double x_nom = fParameterSnapshots[nomSet][i];
          //have 4 numbers: x_up, x_down, x_nom, x_val  
          //need to find the two which straddle x_val or are otherwise closest to x_val 
          if(x_down < x_nom && x_nom < x_up) {
            //standard ordering 
            if(x_nom < x_val) {
              //prefer nom to down
              x_down = x_nom; downIdx=-1;
            } else {
              //prefer nom to up
              upIdx = downIdx; x_up = x_down;
              downIdx=-1; x_down = x_nom;
            }
          } else if(x_up < x_nom && x_nom < x_down) {
            //reverse ordering 
            if(x_nom < x_val) {
              //prefer nom to up
              upIdx = downIdx; x_up = x_down;
              downIdx=-1; x_down = x_nom;
            } else {
              //prefer nom to down 
              x_down = x_nom; downIdx=-1;
            }
          } else {
            //unusual ordering ... not really supported ... 
            //we'd really have to check where x_val is relative to the three values 
            //also the x_up and x_down obtained may not straddle x_val, even if there were values that did
          }
          
        }
        
        //now calculate the value based on interpolation between these two points 
        double y_up(0);
        double y_down(nomVal);
        if(fObsInterpCode) {
          TH1* hh = fHists[upIdx];
          switch(hh->GetDimension()) {
            case 1: y_up = hh->Interpolate(interpCoords[0]); break;
            case 2: y_up = hh->Interpolate(interpCoords[0], interpCoords[1]); break;
            case 3: y_up = hh->Interpolate(interpCoords[0], interpCoords[1], interpCoords[2]); break;
          }
          if(downIdx!=-1) {
            hh = fHists[downIdx];
            switch(hh->GetDimension()) {
              case 1: y_down = hh->Interpolate(interpCoords[0]); break;
              case 2: y_down = hh->Interpolate(interpCoords[0], interpCoords[1]); break;
              case 3: y_down = hh->Interpolate(interpCoords[0], interpCoords[1], interpCoords[2]); break;
            }
          }
          
        } else {
          y_up = fHists[upIdx]->GetBinContent(bin);
          if(downIdx!=-1) y_down = fHists[downIdx]->GetBinContent(bin);
        }
        
        
        
        
        
        
        bool doCode2(false);
        switch(fInterpCode[i]*(downIdx!=-1)) {
        case 0:{ //piecewise linear always used if only one variation
             //if downSet unavailable, use nominal set as the down variation
            double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
            val += (tmpVal - nomVal);
            }break;
        case 2: //6th order poly with log extrapolation 
            doCode2=true;
        case 3:{ //6th order poly with linear extrapolation
            
            
            if(x_val < x_down && x_val < x_up) {
              if(doCode2) {
                val *= (x_down < x_up) ? std::pow(y_down/nomVal, x_val/x_down) : std::pow(y_up/nomVal, x_val/x_up);
              } else {
                //linear extrapolate from x_val and x_down or x_up, whichever is lower 
                if(x_down < x_up) {
                  y_up = nomVal; x_up = fParameterSnapshots[nomSet][i];
                } else {
                  y_down = nomVal; x_down = fParameterSnapshots[nomSet][i];
                }
                double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
                val += (tmpVal - nomVal);
              }
            } else if(x_val > x_up && x_val > x_down) {
              if(doCode2) {
                val *= (x_down < x_up) ? std::pow(y_up/nomVal, x_val/x_up) : std::pow(y_down/nomVal, x_val/x_down);
              } else {
                //linear extrapolate from x_val and x_down or x_up, whichever is lower 
                if(x_down < x_up) {
                  y_down = nomVal; x_down = fParameterSnapshots[nomSet][i];
                } else {
                  y_up = nomVal; x_up = fParameterSnapshots[nomSet][i];
                }
                double tmpVal = ((y_up-y_down)/(x_up-x_down))*(x_val - x_down) + y_down;
                val += (tmpVal - nomVal);
              }
            } else {
              //Code based off what is in HistFactor::PiecewiseInterpolation (interpCode 4)
            
              //scale and shift x values so x_up-x_down = 2 and x_up+x_down=0 (i.e. usual +1, -1 case) 
              //sf even flips x_up and x_down so that x_up > x_down
              //std::cout << "x_val =" << x_val << " x_up=" << x_up << " x_down=" << x_down << std::endl;
              double sf = 2.0/(x_up-x_down);
              x_val *= sf; x_up *= sf; x_down *= sf;
              double sh = (x_up+x_down)/2.0;
              x_val -= sh; 
              double eps_plus = y_up-nomVal; double eps_minus=nomVal-y_down;
              double S = 0.5 * (eps_plus + eps_minus);
              double A = 0.0625 * (eps_plus - eps_minus);
              val += x_val * (S + x_val * A * ( 15 + x_val * x_val * (-10 + x_val * x_val * 3  ) ) );
            }
                    
            }break;
        case 4:{ //6th order polynomial with log extrapolation
            
            if(val==0) break; //since in this mode the corrections to val are entirely multiplicative, if we have 0 we are effectively done
            
            
        
            //scale and shift x values so x_up-x_down = 2 and x_up+x_down=0 (i.e. usual +1, -1 case) 
            //sf even flips x_up and x_down so that x_up > x_down
            
            //std::cout << "x_val =" << x_val << " x_up=" << x_up << " x_down=" << x_down << std::endl;
            double sf = 2.0/(x_up-x_down);
            x_val *= sf; x_up *= sf; x_down *= sf;
            double sh = (x_up+x_down)/2.0;
            x_val -= sh; //x_up -= sh; x_down -= sh; //... x_up and x_down should equal 1 and -1 by this point
            
        
            if(x_val >= 1.) {
              if(fabs(y_up-nomVal)>1e-15) val *= std::pow(y_up/nomVal, x_val);
            } else if(x_val <= -1.) {
              if(fabs(y_down-nomVal)>1e-15) val *= std::pow(y_down/nomVal, -x_val);
            } else if(x_val) {
              //Based off what is in FlexibleInterpVar (interpCode 4)
              
              //coefficients can be precomputed, but are function of nomSet, upSet, downSet indices, bin, and i
              
              double coeff[6];
              
              double pow_up       =  (fabs(y_down-nomVal)>1e-15) ? y_up/nomVal : 1.;
              double pow_down     =  (fabs(y_down-nomVal)>1e-15) ? y_down/nomVal : 1.;
              double logHi        =  std::log(pow_up) ; //BUGFIXED!
              double logLo        =  std::log(pow_down); //BUGFIXED!
              double pow_up_log   = y_up <= 0.0 ? 0.0 : pow_up * logHi;
              double pow_down_log = y_down <= 0.0 ? 0.0 : -pow_down    * logLo;
              double pow_up_log2  = y_up <= 0.0 ? 0.0 : pow_up_log  * logHi;
              double pow_down_log2= y_down <= 0.0 ? 0.0 : -pow_down_log* logLo;
      
              double S0 = (pow_up+pow_down)/2;
              double A0 = (pow_up-pow_down)/2;
              double S1 = (pow_up_log+pow_down_log)/2;
              double A1 = (pow_up_log-pow_down_log)/2;
              double S2 = (pow_up_log2+pow_down_log2)/2;
              double A2 = (pow_up_log2-pow_down_log2)/2;
              
              //fcns+der+2nd_der are eq at bd
              
              // cache  coefficient of the polynomial 
              coeff[0] = 1./(8)        *(      15*A0 -  7*S1 + A2);
              coeff[1] = 1./(8)     *(-24 + 24*S0 -  9*A1 + S2);
              coeff[2] = 1./(4)*(    -  5*A0 +  5*S1 - A2);
              coeff[3] = 1./(4)*( 12 - 12*S0 +  7*A1 - S2);
              coeff[4] = 1./(8)*(    +  3*A0 -  3*S1 + A2);
              coeff[5] = 1./(8)*( -8 +  8*S0 -  5*A1 + S2);
              
              //std::cout << nomVal << " " << y_up << " " << y_down << " " << val << " " << x_val << " " << coeff[0] << " " << coeff[1] << " " << coeff[2] << " " << coeff[3] << " " << coeff[4] << " " << coeff[5] << std::endl;
              
              val *= (1. + x_val * (coeff[0] + x_val * (coeff[1] + x_val * (coeff[2] + x_val * (coeff[3] + x_val * (coeff[4] + x_val * coeff[5]) ) ) ) ) );
              
            }
            
            
            
            }break;
        }

        //std::cout << par->GetName() << " " << val << std::endl;
      }
      
      if(divideByBinWidth && val) { //divide by bin volume if it's necessary to
        if(!gotBinVol) { val /= GetBinVolume(bin); }
        else val *= binVol; //binVol is already inverted
      }
      
      out += val;
    }
  

  
  //multiply by all the norm factors
  RooFIter itr(fNormFactors.fwdIterator());
  while( RooAbsReal* arg = (RooAbsReal*)itr.next() ) out *= arg->getVal(); //NOTE: should we use _normSet? leads to issues if normfactor is a pdf...
  
  //and by the shape factors for this bin
  auto&& fItr = fBinsShapeFactors.find(bin);
  if(fItr!=fBinsShapeFactors.end()) {
    for(auto& sfIdx : fItr->second) {
      out *= ((RooAbsReal&)fShapeFactors[sfIdx]).getVal();
    }
  }
  
  if(kMustBePositive && out < fFloorValue) out=fFloorValue;
  
  return out;
  
}
