/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TRooFit/TRooH1.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

#include "RooAbsLValue.h"
#include "RooRealVar.h"
#include "RooProdPdf.h"
#include "RooPoisson.h"
#include "RooGaussian.h"
#include "RooProduct.h"
#include "RooAddition.h"
#include "RooConstVar.h"

#include "RooDataSet.h"
#include "RooDataHist.h"

#include "RooNumIntConfig.h"

#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"

#include "RooCachedReal.h"

#include "RooBinning.h"

#include "TRooFit/TRooHStack.h"

#include <memory>

#include "TGraphErrors.h"

ClassImp(TRooH1) 
ClassImp(TRooH0D) 


void TRooAbsH1::UseCurrentStyle() {
  if(!gStyle) return;
  SetLineColor(gStyle->GetHistLineColor());
  SetFillStyle(gStyle->GetHistFillStyle());
  SetFillColor(gStyle->GetHistFillColor());
  SetLineStyle(gStyle->GetHistLineStyle());
}

TRooAbsH1::TRooAbsH1(const RooArgList& observables, RooAbsArg* me) : 
	fObservables((observables.getSize()>0)?"obs":"!obs","obs",me),
	fNormFactors("!normFactors","normFactors",me),
        fShapeFactors("!shapeFactors","shapeFactors",me),
        fStatFactors("!statFactors","statFactors",me),
        fMissingBinProxy("!missing","missing",me) {
  fObservables.add(observables);
  fStatFactors.takeOwnership();//default is to own the stat factors .. TRooHStacks can acquire ownership though
  UseCurrentStyle();
  
  
}




TRooAbsH1::TRooAbsH1(const TRooAbsH1& other, RooAbsArg* me) :
  TAttLine(other), TAttFill(other), TAttMarker( other ),
  fObservables(other.fObservables.GetName(),me,other.fObservables),
  fNormFactors(other.fNormFactors.GetName(),me,other.fNormFactors),
  fShapeFactors(other.fShapeFactors.GetName(),me,other.fShapeFactors),
  fStatFactors(other.fStatFactors.GetName(),me,other.fStatFactors),
  fBinsShapeFactors(other.fBinsShapeFactors),
  fRangeName(other.fRangeName),
  fDummyHist(other.fDummyHist),
  kUseAbsPdfValV(other.kUseAbsPdfValV),
  kMustBePositive(other.kMustBePositive),fFloorValue(other.fFloorValue),
   fMissingBin(other.fMissingBin),
   fMissingBinProxy(other.fMissingBinProxy.GetName(),me,other.fMissingBinProxy),kStats(other.kStats),fBlindRangeName(other.fBlindRangeName)
{ 
  //Copy constructor
  if(fRangeName=="") fRangeName=other.GetName(); //FIXME: should we default the fRangeName to name in constructor?
} 



RooAbsReal* TRooAbsH1::createIntegralWM(const RooArgSet& iset,const char* rangeName) const {
  //Create integral with missing events include (WM=With Missing)
  //
  //Returns a function that represents the integral (over iset), including the 'missing events' 
  //user is responsible for deleting the function 
  
  //FIXME: Will need overriding in stacks, to combine all missing bins
  
  RooAbsReal* inte = dynamic_cast<const RooAbsReal*>(this)->createIntegral(iset,rangeName);
  
  if(!fMissingBin) return inte;
  
  //add the missing component 
  return new RooAddition(Form("intWM_%s",GetName()),Form("Integral of %s with missing events",GetTitle()),RooArgList(*inte,*fMissingBin));
  
  
}

Double_t TRooAbsH1::Integral(Option_t* opt) const {
  TString sOpt(opt);
  std::unique_ptr<RooAbsReal> inte( (sOpt.Contains("m")) ?  createIntegralWM(fObservables) : dynamic_cast<const RooAbsReal*>(this)->createIntegral(fObservables) );
  return inte->getVal();
}
Double_t TRooAbsH1::IntegralAndErrorImpl(Double_t& err, const RooFitResult& fr, const char* rangeName, Option_t* opt) const {
  TString sOpt(opt);
  std::unique_ptr<RooAbsReal> inte( (sOpt.Contains("m")) ?  createIntegralWM(fObservables,rangeName) : dynamic_cast<const RooAbsReal*>(this)->createIntegral(fObservables,rangeName) );
  
  //the getPropagatedError method needs protecting from negligible errors 
  TRooFitResult fr2(&fr , 1e-9);
  
  if(sOpt.Contains("v")) {
    fr.Print();
    fr2.floatParsFinal().Print("v");
    fr2.covarianceMatrix().Print();
  }
  
    err = inte->getPropagatedError(fr2);
  

  return inte->getVal();
}

Double_t TRooAbsH1::IntegralAndError(Double_t& err, const TRooFitResult* fr, const char* rangeName, Option_t* opt) const {
  double out=0;
  if(fr==0) {
    //create one with anything that isn't my observables 
    RooArgSet* params =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
    TRooFitResult r(*params);
    delete params;
    out = IntegralAndErrorImpl(err,static_cast<const RooFitResult&>(r),rangeName,opt);
  } else if(fr->floatParsFinal().getSize()==0) {
      //no floating pars ... error would by definition be zero for this case
      //we assume here that isn't what the user wanted ... instead assume they wanted all parameters 
      //that are not in the constPars list 
      RooAbsCollection* cdeps =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
      cdeps->remove(fr->constPars(),true,true);
      RooArgList l; l.add(*cdeps);
      TRooFitResult r(l,fr->constPars());
      out = IntegralAndErrorImpl(err,static_cast<const RooFitResult&>(r),rangeName,opt);
      delete cdeps;
      
      
  } else {
  
    RooAbsCollection* crsnap = 0;
    //also ensure that all non-observables are held constant if they are not specified in the fit result 
    RooAbsCollection* cdeps =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
    
    //check if any of the floatPars have "injectValueAndError" attached ... if they do then we need to setVal and error on them 
    RooAbsCollection* injectPars = fr->floatParsFinal().selectByAttrib("injectValueAndError",true);
    if(injectPars->getSize()) {
      *injectPars = *cdeps; 
      const_cast<TRooFitResult*>(dynamic_cast<const TRooFitResult*>(fr))->resetCovarianceMatrix(); //updates covariance matrix with new errors
    }
    delete injectPars;
    
    cdeps->remove(fr->floatParsFinal(),true,true/*remove by name*/);
    crsnap = cdeps->snapshot();
    *cdeps = fr->constPars(); //move constpars to their location  ... shouldn't be necessary now that i added line to getError method to set constPars values
    cdeps->setAttribAll("Constant",true); //hold everything const now
    
    
    
    out = IntegralAndErrorImpl(err,static_cast<const RooFitResult&>(*fr),rangeName,opt);
    
    *cdeps = *crsnap; //this will also revert constant status
    delete cdeps;
    delete crsnap;
  }
  return out;
}



bool TRooAbsH1::addNormFactor( RooAbsReal& factor ) {
  //Add an overall normalization factor to this TRooFit pdf 
  //If you want the factor to be constrained, you should specify a 
  //constraintType property on the factor 
  //
  //Available constraintTypes: (set with factor.setStringAttribute("constraintType","TYPE") )
  //   normal : constrained by 0, with stdev = 1
  //   gaussian(x,y) : constrained by x, with stdev = y    [gaussian(0,1) == normal]
  

  if(fNormFactors.find( factor )) return false;
  fNormFactors.add( factor ); fNormFactors.setName("normFactors");
  if(fMissingBin) { fMissingBin->addNormFactor( factor ); }
  //need to also tell all clients that we have a new parameter to depend on
  TIterator* citer(dynamic_cast<RooAbsArg*>(this)->clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
  while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
    client->addServer(factor);client->setValueDirty();client->setShapeDirty();
  }
  delete citer;
  resetNormMgr();
  return true;
}

bool TRooAbsH1::addShapeFactor( int bin, RooAbsReal& factor ) {
  //Add a normalization factor to a specific bin of this TRooFit pdf 
  //If you want the factor to be constrained, you should specify a 
  //constraintType property on the factor. See TRooAbsH1::addNormFactor for more info.

  if(!fShapeFactors.find( factor )) {
    fShapeFactors.add( factor ); fShapeFactors.setName("shapeFactors");
    //need to also tell all clients that we have a new parameter to depend on
    TIterator* citer(dynamic_cast<RooAbsArg*>(this)->clientIterator());//std::unique_ptr<TIterator> citer(clientIterator());
    while( RooAbsArg* client = (RooAbsArg*)( citer->Next() ) ) {
      client->addServer(factor);client->setValueDirty();client->setShapeDirty();
    }
    delete citer;
    resetNormMgr();
  }
  fBinsShapeFactors[bin].push_back( fShapeFactors.index( &factor ) );
  return true;
}

bool TRooAbsH1::addShapeFactor( const char* bin, RooAbsReal& factor ) {
  //Same as the other addShapeFactor method, but can be used when the 
  //first (i.e. x-axis) observable of this histogram is a discrete variable

  //first observable must be a category
  if(GetDimension()==0) return addShapeFactor(1,factor);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("addShapeFactor","%s is not a category, cannot fill",fObservables[0].GetName());
    return false;
  }
  auto type = cat->lookupType(bin);
  if(!type) {
    Error("addShapeFactor","%s unknown label in %s",bin,fObservables[0].GetName());
    return false;
  }
  return addShapeFactor( type->getVal() + 1 , factor );
  
}


std::unique_ptr<RooArgSet> TRooAbsH1::GetShapeFactors(int bin) const {
  std::unique_ptr<RooArgSet> out(new RooArgSet(Form("%s_shapeFactors_bin%d",GetName(),bin)));
  if(fBinsShapeFactors.find(bin)==fBinsShapeFactors.end()) return out;
  
  for(auto fIdx : fBinsShapeFactors.at(bin)) {
    out->add( *fShapeFactors.at(fIdx) );
  }
  return out;
  
}

RooRealVar* TRooAbsH1::getStatFactor(int bin, bool createIf) {
    //Obtain the statFactor for the given bin 
    //If createIf = true, then will also create the statFactor 
    //if it doesn't exist. 

    if(fBinsShapeFactors.find(bin)!=fBinsShapeFactors.end()) {
      for(auto fIdx : fBinsShapeFactors.at(bin)) {
        if(fStatFactors.find(*fShapeFactors.at(fIdx))) { return (RooRealVar*)fShapeFactors.at(fIdx); }
      }
    }
    
    //first check if we are a stack ... because possible we can find a stat factor from the components
    if(dynamic_cast<TObject*>(this)->InheritsFrom(TRooAbsHStack::Class())) {
      RooFIter statFactors = fStatFactors.fwdIterator();
      RooRealVar* factor;
      while( ( factor = (RooRealVar*)statFactors.next() ) ) {
        if(TString(factor->getStringAttribute("statBinNumber")).Atoi()==bin) return factor;
      }
    }
    
    
    if(!createIf) return 0; //stop here 
    
    //ok, going to create a statFactor ... first check if we are actually part of a stack
    TRooAbsHStack* stack = 0;
    if(!fStatFactors.isOwning()) { //stack owns stat 
      //look for a stack in our clients ... add our stat factor there
      std::unique_ptr<TIterator> clients(dynamic_cast<RooAbsArg*>(this)->clientIterator());
      
      while(TObject* a = clients->Next()) {
        if(a->InheritsFrom(TRooAbsHStack::Class())) { stack = (TRooAbsHStack*)a; break; }
      }
      if(!stack) { std::cout << "COULD NOT FIND MY STACK!???" << std::endl; }
      else {
        //see if there's a good stat variable in the stack we can use
        RooFIter statFactors = stack->fStatFactors.fwdIterator();
        RooRealVar* factor;
        while( ( factor = (RooRealVar*)statFactors.next() ) ) {
          if(TString(factor->getStringAttribute("statBinNumber")).Atoi()==bin) {
            //found a good statFactor .. we now must add the content and sumw2 of ourselves
            factor->setStringAttribute("constraintType","statPoisson");
            factor->setStringAttribute("sumw",Form("%e",(TString(factor->getStringAttribute("sumw")).Atof() + getNominalHist()->GetBinContent(bin)))); 
            factor->setStringAttribute("sumw2",Form("%e",(TString(factor->getStringAttribute("sumw2")).Atof() + pow(getNominalHist()->GetBinError(bin),2)))); 
            factor->setError(sqrt((TString(factor->getStringAttribute("sumw2")).Atof()))/(TString(factor->getStringAttribute("sumw")).Atof()));
            if(std::isnan(factor->getError())||std::isinf(factor->getError())) factor->setError(1e9);
            addShapeFactor( bin, *factor );
            return factor;
          }
        }
      }
    }
    
    //got here, ok just have to create a new factor 
    
    //Note: this will assume that the stat error can only get up to 5 times bigger than the central value!
    RooRealVar* statFactor = new RooRealVar(Form("%s_stat_bin%d",(stack)?stack->GetName():GetName(),bin),Form("Stat factor bin %d",bin),1,0,5);
    statFactor->setStringAttribute("statBinNumber",Form("%d",bin));
    statFactor->setStringAttribute("constraintType","statPoisson");
    statFactor->setStringAttribute("sumw",Form("%e",getNominalHist()->GetBinContent(bin))); 
    statFactor->setStringAttribute("sumw2",Form("%e",pow(getNominalHist()->GetBinError(bin),2))); 
    if(getNominalHist()->GetBinError(bin)) {
      statFactor->setError(sqrt((TString(statFactor->getStringAttribute("sumw2")).Atof()))/(TString(statFactor->getStringAttribute("sumw")).Atof()));
      if(std::isnan(statFactor->getError())||std::isinf(statFactor->getError())) statFactor->setError(1e9);
    }
    if(!stack) {
      fStatFactors.addOwned(*statFactor); fStatFactors.setName("statFactors");
    } else {
      stack->fStatFactors.addOwned(*statFactor); //add to stack's statFactors
      fStatFactors.add(*statFactor); //add to my own list of stat factors
    }
    addShapeFactor(bin,*statFactor);
    return statFactor; 
    

}

Int_t TRooAbsH1::FindFixBin( double x, double y, double z ) const {

  return fDummyHist->FindFixBin(x,y,z); //just use the hist

  int out = 0; int factor = 1;
  for(int i=0;i<fObservables.getSize();i++) {
    double bin = 0;
    if(i==0) {
      //use x value to get bin
      if( fObservables[i].InheritsFrom( RooAbsCategory::Class() ) ) {
        bin = int(x+0.5); //assume x is an index
      } else {
        auto binning = dynamic_cast<RooAbsLValue&>(fObservables[i]).getBinningPtr(GetRangeName());
        if(x < binning->lowBound()) bin = 0;
        else if(x > binning->highBound()) bin = binning->numBins()+1;
        else bin = binning->binNumber(x)+1;
      }
    }
    
    
    out += factor*bin;
    
    if( fObservables[i].InheritsFrom( RooAbsCategory::Class() ) ) {
      //discrete variable, so no need to cover for overflows
      out -= factor;
      //now increase factor by number of categories
      factor *= static_cast<RooAbsCategory&>(fObservables[i]).numTypes();
    } else {
      factor *= (static_cast<RooRealVar&>(fObservables[i]).numBins()+2);
    }
    
    //increase factor by number of bins (if observable was category) or bins + 2 (if continuous)
  }
  return out;
}

Double_t TRooAbsH1::GetBinVolume(int bin) const {
  double binVol(1.);
  int bb[3]; fDummyHist->GetBinXYZ(bin,bb[0],bb[1],bb[2]);
  for(int i=0;i<fDummyHist->GetDimension();i++) {
    TAxis* ax = 0; if(i==0) ax = fDummyHist->GetXaxis(); else if(i==1) ax = fDummyHist->GetYaxis(); //FIXME: assumes 2D at most
    binVol *= ax->GetBinWidth(bb[i]);
  }
  return binVol;
}

Double_t TRooAbsH1::getBinVolume() const {
  double out = 1.;
  RooFIter itr(fObservables.fwdIterator());
  RooAbsArg* arg = 0;
  while( (arg = itr.next()) ) {
    if(arg->IsA() != RooRealVar::Class()) continue;
    RooRealVar* v = static_cast<RooRealVar*>(arg);
    out *= v->getBinWidth( v->getBin(GetRangeName()) , GetRangeName() );
  }
  return out;

/*  int dim = GetDimension();
  if(dim==0) return 1;
  
  double out = 1;
  int bb[3]; fHists[0]->GetBinXYZ(getBin(),bb[0],bb[1],bb[2]);
  for(int i=0;i<dim;i++) {
    TAxis* ax = 0; if(i==0) ax = fHists[0]->GetXaxis(); else if(i==1) ax = fHists[0]->GetYaxis(); //FIXME: assumes 2D at most
    out *= ax->GetBinWidth(bb[i]);
  }
  return out;
*/
}



Int_t TRooAbsH1::getBin(const char* rangeName) const {
  if(GetDimension()==0) return 1;
  int out = 0; int factor = 1;
  const char* rName = GetRangeName(rangeName);
  
  RooFIter itr( fObservables.fwdIterator() );
  RooAbsArg* obs = 0;
  while( (obs = itr.next()) ) {
    double bin = 0;
    RooAbsLValue* lal = dynamic_cast<RooAbsLValue*>(obs);
    if(!obs->inRange(rName)) {
      //see if is under or overflow
      RooRealVar* rar = static_cast<RooRealVar*>(obs);
      if(rar->getVal() > rar->getMax(rName))  {
        bin = rar->numBins(rName)+2;
      } 
    } else {
      bin = lal->getBin(rName)+1; 
    }
    out += factor*bin;
    
    factor *= (lal->numBins(rName)+2);
    
    /*
    if( obs->InheritsFrom( RooAbsCategory::Class() ) ) {
      //discrete variable, so no need to cover for overflows
      //out -= factor;
      //now increase factor by number of categories
      factor *= (static_cast<RooAbsCategory&>(*obs).numTypes(rName)+2);
    } else {
      factor *= (static_cast<RooRealVar&>(*obs).numBins(rName)+2);
    }
    */
    //increase factor by number of bins (if observable was category) or bins + 2 (if continuous)
  }
  return out;
}

Double_t TRooAbsH1::GetBinError(int bin, const RooFitResult* fr) const { 
  
    //convert global bin number into local bin, using current GetRangeName ...
  int binx(0),biny(0),binz(0);
  switch(GetDimension()) {
    case 1: binx = bin; break; //simple case
    case 2: binx = bin % (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            biny = bin / (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            break;
    case 3: binx = bin % ((dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2)*(dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2));
            //FIXME biny = bin % (dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2);
            //FIXME binz
  }
  int tmpVals[3] = {0,0,0};
  switch(GetDimension()) {
    case 3: tmpVals[2] = dynamic_cast<RooAbsLValue&>(fObservables[2]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(binz-1,GetRangeName());
    case 2: tmpVals[1] = dynamic_cast<RooAbsLValue&>(fObservables[1]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(biny-1,GetRangeName());
    case 1: tmpVals[0] = dynamic_cast<RooAbsLValue&>(fObservables[0]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(binx-1,GetRangeName());
  }
  double out(0);
  if(fr==0) {
    //create one with anything that isn't my observables 
    RooArgSet* params =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
    TRooFitResult r(*params);
    delete params;
    out = getBinError(r);
  } else { out = getBinError(*fr); } /* MOVED ALL THIS LOGIC TO getError method, so that shared by fillGraph etc
  else if(fr->floatParsFinal().getSize()==0) {
      //no floating pars ... error would by definition be zero for this case
      //we assume here that isn't what the user wanted ... instead assume they wanted all parameters 
      //that are not in the constPars list 
      RooAbsCollection* cdeps =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
      cdeps->remove(fr->constPars(),true,true);
      RooArgList l; l.add(*cdeps);
      TRooFitResult r(l,fr->constPars());
      out = getBinError(r);
      delete cdeps;
      
      
  } else {
  
    RooAbsCollection* crsnap = 0;
    //also ensure that all non-observables are held constant if they are not specified in the fit result 
    RooAbsCollection* cdeps =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
    
    //check if any of the floatPars have "injectValueAndError" attached ... if they do then we need to setVal and error on them 
    RooAbsCollection* injectPars = fr->floatParsFinal().selectByAttrib("injectValueAndError",true);
    if(injectPars->getSize()) {
      *injectPars = *cdeps; 
      const_cast<TRooFitResult*>(dynamic_cast<const TRooFitResult*>(fr))->resetCovarianceMatrix(); //updates covariance matrix with new errors
    }
    delete injectPars;
    
    cdeps->remove(fr->floatParsFinal(),true,true);
    crsnap = cdeps->snapshot();
    *cdeps = fr->constPars(); //move constpars to their location  ... shouldn't be necessary now that i added line to getError method to set constPars values
    cdeps->setAttribAll("Constant",true); //hold everything const now
    
    
    
    out = getBinError(*fr);
    
    *cdeps = *crsnap; //this will also revert constant status
    delete cdeps;
    delete crsnap;
  }*/
  switch(GetDimension()) {
    case 3: dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(tmpVals[2],GetRangeName());
    case 2: dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(tmpVals[1],GetRangeName());
    case 1: dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(tmpVals[0],GetRangeName());
  }
  return out;
  

}

Double_t TRooAbsH1::GetBinContent(int bin, const RooFitResult* r) const {
  //convert global bin number into local bin, using current GetRangeName ...
  int binx(0),biny(0),binz(0);
  switch(GetDimension()) {
    case 1: binx = bin; break; //simple case
    case 2: binx = bin % (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            biny = bin / (dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2);
            break;
    case 3: binx = bin % ((dynamic_cast<RooAbsLValue&>(fObservables[0]).numBins(GetRangeName())+2)*(dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2));
            //FIXME biny = bin % (dynamic_cast<RooAbsLValue&>(fObservables[1]).numBins(GetRangeName())+2);
            //FIXME binz
  }
  
  
  //fHists[0]->GetBinXYZ(bin,binx,biny,binz);
  int tmpVals[3] = {0,0,0};
  switch(GetDimension()) {
    case 3: tmpVals[2] = dynamic_cast<RooAbsLValue&>(fObservables[2]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(binz-1,GetRangeName());
    case 2: tmpVals[1] = dynamic_cast<RooAbsLValue&>(fObservables[1]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(biny-1,GetRangeName());
    case 1: tmpVals[0] = dynamic_cast<RooAbsLValue&>(fObservables[0]).getBin(GetRangeName()); dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(binx-1,GetRangeName());
  }
  RooAbsCollection* deps = 0;RooAbsCollection* cdeps = 0;
  RooAbsCollection* rsnap = 0;RooAbsCollection* crsnap = 0;
  if(r) {
    //move onto finalPars values 
    deps = dynamic_cast<const RooAbsArg*>(this)->getDependents(r->floatParsFinal());
    rsnap = deps->snapshot();
    *deps = r->floatParsFinal(); //overrides with values from fit result
    //likewise for constPars 
    cdeps =  dynamic_cast<const RooAbsArg*>(this)->getDependents(r->constPars());
    crsnap = cdeps->snapshot();
    *cdeps = r->constPars(); cdeps->setAttribAll("Constant",true);
  }
  double out = getBinContent(fObservables);
  if(r) {
    *deps = *rsnap;
    *cdeps = *crsnap; //this will also revert constant status
    delete deps;delete cdeps;
    delete rsnap;delete crsnap;
  }
  switch(GetDimension()) {
    case 3: dynamic_cast<RooAbsLValue&>(fObservables[2]).setBin(tmpVals[2],GetRangeName());
    case 2: dynamic_cast<RooAbsLValue&>(fObservables[1]).setBin(tmpVals[1],GetRangeName());
    case 1: dynamic_cast<RooAbsLValue&>(fObservables[0]).setBin(tmpVals[0],GetRangeName());
  }
  return out;
}


Double_t TRooAbsH1::GetBinContent(const char* bin, const RooFitResult* r) const {
  //first observable must be a category
  if(GetDimension()==0) return GetBinContent(1,r);
  
  RooCategory* cat = dynamic_cast<RooCategory*>(&fObservables[0]);
  if(!cat) {
    Error("GetBinContent","%s is not a category, cannot fill",fObservables[0].GetName());
    return false;
  }
  auto type = cat->lookupType(bin);
  if(!type) {
    Error("GetBinContent","%s unknown label in %s",bin,fObservables[0].GetName());
    return false;
  }
  return GetBinContent( type->getVal() + 1 , r );
  
}

TAxis* TRooAbsH1::GetXaxis() const {
  //Retrieve the x-axis
  return fDummyHist->GetXaxis();
}

TAxis* TRooAbsH1::GetYaxis() const {
  //Retrieve the y-axis
  return fDummyHist->GetYaxis();
}



RooAbsPdf& TRooAbsH1::model() {

  //first check if constraints are needed
  RooArgSet* nodes = dynamic_cast<RooAbsArg*>(this)->getParameters(fObservables);
  RooFIter itr = nodes->fwdIterator();
  RooAbsArg* arg = 0;
  bool hasConstraint(false);
  while( (arg = itr.next()) ) {
    if(!arg->isFundamental()) continue;
    if(arg->isConstant()) continue;
    if(!arg->getStringAttribute("constraintType")) continue;
    hasConstraint=true; break;
  }
  if(hasConstraint) {
    if(!fThisWithConstraints) fThisWithConstraints = buildConstraints(fObservables,"",true);
    return *fThisWithConstraints;
  }
  return dynamic_cast<RooAbsPdf&>(*this);
}

RooProdPdf* TRooAbsH1::buildConstraints(const RooArgSet& obs, const char* systGroups,bool addSelf) const {
  
  RooProdPdf* out = 0;
  RooArgList constraints; if(addSelf) constraints.add(*dynamic_cast<const RooAbsArg*>(this));
  //find all primitive servers, and for the ones in my systGroups
  //assemble constraints according to constraintType
  //if none given, then leave unconstrained!
  //RooArgSet nodes;
  //treeNodeServerList(&nodes);
  RooArgSet* nodes =  dynamic_cast<const RooAbsArg*>(this)->getParameters(obs);
  RooFIter itr = nodes->fwdIterator();
  RooAbsArg* arg = 0;
  while( (arg = itr.next()) ) {
    if(!arg->isFundamental()) continue;
    if(arg->isConstant()) continue;
    if(!arg->getStringAttribute("constraintType")) {
      Info("buildConstraints","%s is an unconstrained free parameter",arg->GetName());
      continue;
    }
    TString cType = arg->getStringAttribute("constraintType");
    cType.ToUpper();
    if(cType == "STATPOISSON" ) {
    
      //this factor is poisson constrained to be: gamma = 1 +/- sqrt(sumw2)/sumw
      //this means constraint with Pois(gobs|gamma*tau) where observed gobs=tau,
      //and tau = (sumw)^2/sumw2
      RooConstVar* tau = new RooConstVar(Form("tau_%s",arg->GetName()),Form("tau_%s",arg->GetName()),
                        pow(TString(arg->getStringAttribute("sumw")).Atof(),2)/TString(arg->getStringAttribute("sumw2")).Atof());
      if(std::isnan(tau->getVal()) || std::isinf(tau->getVal())) {
        Warning("buildConstraints","%s is nan or inf (sumw=%s, sumw2=%s)",tau->GetName(),arg->getStringAttribute("sumw"),arg->getStringAttribute("sumw2"));
      } else if(tau->getVal()<=1e-9) {
        Warning("buildConstraints","%s has zero tau factor ... setting this factor constant!",arg->GetName());
        delete tau;
        dynamic_cast<RooRealVar*>(arg)->setConstant(true); continue;
      } else {
        //adjust the range of the stat factor to 5*sqrt(tau) 
        dynamic_cast<RooRealVar*>(arg)->setRange( ((1. - 5.*sqrt(1./tau->getVal())) <= 0) ? 0. : (1. - 5.*sqrt(1./tau->getVal())) , 1. + 5.*sqrt(1./tau->getVal()) );
        
      }
      
      RooRealVar* gobs = new RooRealVar(Form("gobs_%s",arg->GetName()),Form("Global observable for %s",arg->GetName()),
                        tau->getVal());gobs->setConstant();
      RooProduct* mean = new RooProduct(Form("mean_%s",arg->GetName()),"",RooArgList(*arg,*tau));
      RooPoisson* p = new RooPoisson(Form("pois_%s",arg->GetName()),Form("TRooFit-generated constraint for %s",arg->GetTitle()),*gobs,*mean);
      constraints.add(*p);
      
      //also set the error on the parameter if it's error is zero 
      RooRealVar* rrv = dynamic_cast<RooRealVar*>(arg);if(rrv && !rrv->getError()) rrv->setError(1./sqrt(tau->getVal()));
      
    } else if(cType =="NORMAL") {
      Info("buildConstraints","%s is normal(gobs=0,sigma=1) constrained free parameter",arg->GetName());
      //normal constraint
      RooRealVar* gobs = new RooRealVar(Form("gobs_%s",arg->GetName()),Form("Global observable for %s",arg->GetName()),0);gobs->setConstant();
      RooConstVar* sigma = new RooConstVar("1","1",1);
      RooGaussian* p = new RooGaussian(Form("gaus_%s",arg->GetName()),Form("TRooFit-generated constraint for %s",arg->GetTitle()),*gobs,*dynamic_cast<RooAbsReal*>(arg),*sigma);
      constraints.add(*p);
      
      //also set the error on the parameter if it's error is zero 
      RooRealVar* rrv = dynamic_cast<RooRealVar*>(arg);if(rrv && !rrv->getError()) rrv->setError(1.);
      
    } else if(cType.BeginsWith("GAUSSIAN(")) {
      //gaussian ... need to extract the auxObs (aka mean) and stdev from the attribute 
      //syntax is: gaussian(auxObs,stddev)
      double auxObs = TString(cType(9,cType.Index(",")-9)).Atof();
      TString stddevStr = TString(cType(cType.Index(",")+1,cType.Index(")")-(cType.Index(","))-1));
      Info("buildConstraints","%s is gaussian(gobs=%g,sigma=%s) constrained free parameter",arg->GetName(),auxObs,stddevStr.Data());
      RooRealVar* gobs = new RooRealVar(Form("gobs_%s",arg->GetName()),Form("Global observable for %s",arg->GetName()),auxObs);gobs->setConstant();
      RooConstVar* sigma = new RooConstVar(stddevStr,stddevStr,stddevStr.Atof());
      RooGaussian* p = new RooGaussian(Form("gaus_%s",arg->GetName()),Form("TRooFit-generated constraint for %s",arg->GetTitle()),*gobs,*dynamic_cast<RooAbsReal*>(arg),*sigma);
      constraints.add(*p);
      
      //also set the error on the parameter if it's error is zero 
      RooRealVar* rrv = dynamic_cast<RooRealVar*>(arg);if(rrv && !rrv->getError()) rrv->setError(stddevStr.Atof());
      
    } else {
      Warning("buildConstraints","%s has unknown constraintType: %s", arg->GetName(), arg->getStringAttribute("constraintType"));
    }
  }
  delete nodes;
  out = new RooProdPdf((addSelf)?Form("%s_with_Constraints",GetName()):Form("Constraints_of_%s",GetName()),
                       (addSelf)?Form("%s_with_Constraints",GetName()):Form("Constraints_of_%s",GetName()),constraints);
  return out;
}


TH1* TRooAbsH1::createOrAdjustHistogram(TH1* hist, bool noBinLabels) const {
  if(!hist) {
    hist = (TH1*)fDummyHist->Clone(GetName());
    hist->SetDirectory(0);
  }
  hist->Reset();
  hist->SetTitle(GetTitle());
  
  hist->SetMaximum( fMaximum );
  hist->SetMinimum( fMinimum );
  hist->SetStats( kStats );
  
  const char* rname = GetRangeName();
  RooAbsLValue* obs[3] = {0,0,0}; 

  
  (*static_cast<TAttFill*>(hist)) = *this;
  (*static_cast<TAttLine*>(hist)) = *this;
  (*static_cast<TAttMarker*>(hist)) = *this;
  //propate axis titles, and bin labels in the case of categories
  switch(GetDimension()) {
    case 2: {
      RooAbsArg& arg = fObservables[1];
      RooAbsReal* argreal = dynamic_cast<RooAbsReal*>(&arg);
      if(!strlen(hist->GetYaxis()->GetTitle())) {
        if(argreal && strlen(argreal->getUnit()))  hist->GetYaxis()->SetTitle(Form("%s [%s]",arg.GetTitle(),argreal->getUnit()));
        else hist->GetYaxis()->SetTitle(arg.GetTitle());
      }
      if(arg.InheritsFrom(RooCategory::Class())) {
      
      } else {
        obs[1] = dynamic_cast<RooAbsLValue*>(&arg);
        //rebin happens below
      }
    }
    case 1: {
      RooAbsArg& arg = fObservables[0];
      RooAbsReal* argreal = dynamic_cast<RooAbsReal*>(&arg);
      if(!strlen(hist->GetXaxis()->GetTitle())) {
        if(argreal && strlen(argreal->getUnit()))  hist->GetXaxis()->SetTitle(Form("%s [%s]",arg.GetTitle(),argreal->getUnit()));
        else hist->GetXaxis()->SetTitle(arg.GetTitle());
      }
      if(arg.InheritsFrom(RooCategory::Class())) {
        RooCategory* cat = dynamic_cast<RooCategory*>(&arg);
        std::unique_ptr<TIterator> itr(cat->typeIterator());
        RooCatType* tt = 0; int binCount=1; int numBins=0;
        while((tt=(RooCatType*)itr->Next())) {
          if(cat->isStateInRange(tt->GetName(),rname)) numBins++;
        }
        hist->SetBins( numBins, -0.5, numBins-0.5 ); //FIXME : shouldn't rebin here :-(
        if(!noBinLabels) {
          itr->Reset();
          while((tt=(RooCatType*)itr->Next())) {
            if(cat->isStateInRange(tt->GetName(),rname)) hist->GetXaxis()->SetBinLabel(binCount++,tt->GetName());
          }
        }
      } else {
        obs[0] = dynamic_cast<RooAbsLValue*>(&arg);
        //rebin happens below
      }
    }
    break;
    case 0: {
      //simple number term. Just have one bin and label it with my title 
      hist->SetBins( 1, -0.5, 0.5 );
      
      if(!noBinLabels) hist->GetXaxis()->SetBinLabel(1,(dynamic_cast<const TNamed*>(this))->GetTitle());
    
    }
    
  }
  
  if(obs[1] && obs[0]) {
    //2D rebin 
    hist->SetBins( obs[0]->numBins(rname) , obs[0]->getBinningPtr(rname)->array() , obs[1]->numBins(rname) , obs[1]->getBinningPtr(rname)->array() );
  } else if(obs[0]) {
    //1D rebin
    hist->SetBins( obs[0]->numBins(rname) , obs[0]->getBinningPtr(rname)->array() );
  }
  
  return hist;
  
}


#include <limits>
TH1* TRooAbsH1::GetHistogram(const RooFitResult* r, bool includeErrors, TH1* histToFill) const {

  if(!histToFill) histToFill = fDrawHistogram;

  if(!histToFill) { 
    fDrawHistogram = (TH1*)fDummyHist->Clone(GetName());
    fDrawHistogram->SetDirectory(0);fDrawHistogram->Reset();
    histToFill = fDrawHistogram;
  }
  
  if(histToFill==fDrawHistogram) createOrAdjustHistogram(histToFill);
  
  fillHistogram(histToFill,r,includeErrors);
  
  return histToFill;
}

void TRooAbsH1::fillHistogram(TH1* histToFill, const RooFitResult* r, bool includeErrors) const {
  histToFill->Reset();
  //loop over bins and fill
  for(int i=1;i<=histToFill->GetNbinsX();i++) {
    double val = GetBinContent(i,r);
    if(val) histToFill->SetBinContent(i,val);
    if(includeErrors) {
      histToFill->SetBinError(i,GetBinError(i,r));
    }
  }
}

void TRooAbsH1::fillGraph(TGraph* graphToFill, const RooFitResult* r, bool includeErrors, int nPoints) const {
  if(nPoints>0) {
    TRooFitResult* myR = 0;
    if(includeErrors) {
      if(graphToFill->IsA() != TGraphErrors::Class()) {
        Error("fillGraph","Must receive TGraphErrors to fill errors. Will skip error filling");
        includeErrors = false;
      }
      if(r==0) {
        //default to propgating the uncertainties of all parameters
        RooArgSet* params =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
        myR = new TRooFitResult(*params); r = myR;
        delete params;
      }
    }
    //sample between min and max with nPoints
    graphToFill->Set(nPoints); //FIXME: remove points over nPoints
    //FIXME: handle discrete variables!
    double low = fDummyHist->GetXaxis()->GetBinLowEdge(1);
    double high = fDummyHist->GetXaxis()->GetBinLowEdge(fDummyHist->GetXaxis()->GetNbins()+1);
    RooAbsRealLValue* obs[3] = {0,0,0}; double tmpVals[3] = {0,0,0};
    if(fObservables.getSize()>0) {obs[0] = dynamic_cast<RooAbsRealLValue*>(&fObservables[0]); tmpVals[0]=obs[0]->getVal(); }
    double expec = expectedEvents(fObservables);
    for(int i=0;i<nPoints;i++) {
      double x = low + i*(high-low)/(nPoints-1);
      if(obs[0]) obs[0]->setVal( x );
      graphToFill->SetPoint(i, x, getVal(fObservables)*expec );
      if(includeErrors) {
        (static_cast<TGraphErrors*>(graphToFill))->SetPointError(i,0,getError(*r));
      }
    }
    for(int i=0;i<3;i++) if(obs[i]) obs[i]->setVal(tmpVals[i]);
    if(myR) delete myR;
  }
}




#include "TVectorD.h"

///BORROWED THIS CODE FROM RooAbsReal
///But added dependencies on expectedEvents too!
//_____________________________________________________________________________
Double_t TRooAbsH1::getError(const RooFitResult& fr) const 
{

  if(fr.floatParsFinal().getSize()==0) {
      //no floating pars ... error would by definition be zero for this case
      //we assume here that isn't what the user wanted ... instead assume they wanted all parameters 
      //that are not in the constPars list 
      RooAbsCollection* cdeps =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables);
      cdeps->remove(fr.constPars(),true,true);
      double out=0;
      if(cdeps->getSize()) {
        RooArgList l; l.add(*cdeps);
        TRooFitResult r(l,fr.constPars());
        out = getError(r);
      }
      delete cdeps;
      return out;
      
  } else {
  //check if any of the floatPars have "injectValueAndError" attached ... if they do then we need to setVal and error on them 
    RooAbsCollection* injectPars = fr.floatParsFinal().selectByAttrib("injectValueAndError",true);
    if(injectPars->getSize()) {
      RooAbsCollection* cdeps =  dynamic_cast<const RooAbsArg*>(this)->getParameters(fObservables); //everything except observables
      *injectPars = *cdeps; 
      const_cast<TRooFitResult&>(dynamic_cast<const TRooFitResult&>(fr)).resetCovarianceMatrix(); //updates covariance matrix with new errors
      delete cdeps;
    }
    delete injectPars;
  }
  // Calculate error on self by propagated errors on parameters with correlations as given by fit result
  // The linearly propagated error is calculated as follows
  //                                    T            
  // error(x) = F_a(x) * Corr(a,a') F_a'(x)
  //
  // where     F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result
  //       Corr(a,a') = the correlation matrix from the fit result
  //


  // Clone self for internal use
  RooAbsReal* cloneFunc = (RooAbsReal*)(dynamic_cast<const RooAbsReal*>(this)->cloneTree()) ;
  RooArgSet* errorParams = cloneFunc->getObservables(fr.floatParsFinal()) ;
  RooArgSet* nset = cloneFunc->getParameters(*errorParams) ;
  //remove const pars from nset ...
  
  //DONT NEED TO SNAP because we cloneTreed ... RooArgSet nsnap; nset->snapshot(nsnap);
  *nset = fr.constPars(); //also ensure any const parameters are set to their respective values 
  
  //nset->remove( fr.constPars(),false,true );
  auto constpars = nset->selectByAttrib("Constant",true); //this is more certain to catch the constant parameters and not normalize on them
  nset->remove(*constpars); delete constpars;
  
  
  // Make list of parameter instances of cloneFunc in order of error matrix
  RooArgList paramList ;
  const RooArgList& fpf = fr.floatParsFinal() ;
  std::vector<int> fpf_idx ;
  for (Int_t i=0 ; i<fpf.getSize() ; i++) {
    RooAbsArg* par = errorParams->find(fpf[i].GetName()) ;
    //if (par) {
    if(par && ((RooRealVar&)fpf[i]).getError()>1e-9) { //WB2017: added this line to stop tiny errors breaking things
      paramList.add(*par) ;
      fpf_idx.push_back(i) ;
    }
  }
  
  if(paramList.getSize()==0) {
    delete cloneFunc; delete errorParams; delete nset;
    return 0; //no error
  }

  //DONT NEED TO SNAP BECAUSE WE cloneTree'd! RooArgSet psnap;errorParams->snapshot(psnap); //save the current values
  *errorParams = fpf; //sets all param values to central values, including ones that had no error in floatParsFinal
  

  std::vector<Double_t> plusVar, minusVar ;    
  
  // Create vector of plus,minus variations for each parameter  
  TMatrixDSym V(paramList.getSize()==fr.floatParsFinal().getSize()?
		fr.covarianceMatrix():
		fr.reducedCovarianceMatrix(paramList)) ;
  
  for (Int_t ivar=0 ; ivar<paramList.getSize() ; ivar++) {
    
    RooRealVar& rrv = (RooRealVar&)fpf[fpf_idx[ivar]] ;
    
    Double_t cenVal = rrv.getVal() ;
    Double_t errVal = sqrt(V(ivar,ivar)) ;
    
    
    // Make Plus variation
    ((RooRealVar*)paramList.at(ivar))->setVal(cenVal+errVal) ;
    plusVar.push_back(cloneFunc->getVal(nset)*(dynamic_cast<TRooAbsH1*>(cloneFunc))->expectedEvents(nset)) ;
    // Make Minus variation
    ((RooRealVar*)paramList.at(ivar))->setVal(cenVal-errVal) ;
    minusVar.push_back(cloneFunc->getVal(nset)*(dynamic_cast<TRooAbsH1*>(cloneFunc))->expectedEvents(nset)) ;
    ((RooRealVar*)paramList.at(ivar))->setVal(cenVal) ;
    
  }

  TMatrixDSym C(paramList.getSize()) ;      
  std::vector<double> errVec(paramList.getSize()) ;
  for (int i=0 ; i<paramList.getSize() ; i++) {
    errVec[i] = sqrt(V(i,i)) ;
    for (int j=i ; j<paramList.getSize() ; j++) {
      C(i,j) = V(i,j)/sqrt(V(i,i)*V(j,j)) ;
      C(j,i) = C(i,j) ;
    }
  }
  
  // Make vector of variations
  TVectorD F(plusVar.size()) ;
  for (unsigned int j=0 ; j<plusVar.size() ; j++) {
    F[j] = (plusVar[j]-minusVar[j])/2 ;
  }
  
  //*errorParams = psnap; //puts all params back
  //*nset = nsnap;

  // Calculate error in linear approximation from variations and correlation coefficient
  Double_t sum = F*(C*F) ;


  delete cloneFunc ;
  delete errorParams ;
  delete nset ;

  return sqrt(sum);
}



void TRooAbsH1::Paint(Option_t*) {
    //Paint the histograms of the current pad
    
    //first ensure the last drawn histogram is appropriately styled
    if(fDrawHistograms.size()) {
      if(fDrawHistograms.back().hist->InheritsFrom(TGraph::Class()) && fDrawHistograms.back().opt.Contains("e")) {
        //drawing a 'value' graph, so only propagate markers and lines, not fill style
        (*dynamic_cast<TAttLine*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttMarker*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttFill*>(fDrawHistograms.back().hist)).SetFillColor( this->GetLineColor() ); //fill color matches line color
      } else {
        (*dynamic_cast<TAttFill*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttLine*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttMarker*>(fDrawHistograms.back().hist)) = *this;
        if(fDrawHistograms.back().postHist) {
          //copy over to posthist too .. but check what type of posthist it is
          if(!strcmp(fDrawHistograms.back().postHist->GetOption(),"e2same")) {
            //is an errorbar hist, so only copy line width and line color
            (*dynamic_cast<TAttLine*>(fDrawHistograms.back().postHist)).SetLineWidth( this->GetLineWidth() );
            (*dynamic_cast<TAttFill*>(fDrawHistograms.back().postHist)).SetFillColor( this->GetLineColor() );
          }
          
        }
      }
      
      /*
      if(fDrawHistograms.back().hist->InheritsFrom(TH1::Class())) {
        // cant use this method unless we refill the hist TRooAbsH1::createOrAdjustHistogram( static_cast<TH1*>(fDrawHistograms.back().hist) );
        (*dynamic_cast<TAttFill*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttLine*>(fDrawHistograms.back().hist)) = *this;
        (*dynamic_cast<TAttMarker*>(fDrawHistograms.back().hist)) = *this;
      } else if(fDrawHistograms.back().hist->InheritsFrom(TGraph::Class())) {
        //FIXME: style the graph

      }
      */
    }
    
    
//     double currMax = -1e50; double currMin = 1e50;
//     std::vector<TH1*> hists;
/*
    for(auto& hist : fDrawHistograms) {
      if(hist.pad == gPad) {  
        if(hist.hist->InheritsFrom(TH1::Class())) {
          TRooAbsH1::fillHistogram(static_cast<TH1*>(hist.hist),hist.fr,true); //updates with current value
        } else if(hist.hist->InheritsFrom(TGraph::Class())) {
          TRooAbsH1::fillGraph(static_cast<TGraph*>(hist.hist),hist.fr,true); //updates with current value
        }
        //hist.hist->Paint(hist.opt); ..don't paint here because added histogram to primitives directly (above)
        
        ///FIXME: wanted a way to auto-adjust the frame limits based on histograms we are drawing
//         hists.push_back(hist.hist);
//         if(hist.hist->GetMaximum() > currMax) {
//           currMax = hist.hist->GetMaximum();
//           for(auto& h : hists) h->SetMaximum(currMax);
//         }
//         if(hist.hist->GetMinimum() < currMin) {
//           currMin = hist.hist->GetMinimum();
//           for(auto& h : hists) h->SetMinimum(currMin);
//         }
      }
    }
*/

//     if(!fDrawHistogram) GetHistogram(fDrawFitResult,true); 
//     else TRooAbsH1::fillHistogram(fDrawHistogram,fDrawFitResult,true); //updates with current values
//     fDrawHistogram->Paint(option); 
}

#include "TROOT.h"
#include "TPad.h"
void TRooAbsH1::Draw(Option_t *option)
{
  //Draw method taking just an option
  //option is used to construct a TRooFitResult that can be used to set parameters
  //constant at a given value
  //I.e. you can do: Draw("param=value") to draw this pdf at the given value

  //FIXME: should really remove from option any bits that got used successfully for constPars construction
   TRooAbsH1::Draw(option,TRooFitResult(option));
}

#include "TRooFit/TRooHF1.h"

void TRooAbsH1::Draw(Option_t* option,const TRooFitResult& r) {
  //Main Draw method for TRooFit pdfs 
  //See the concrete implementations for more details:
  //    TRooH1D::Draw 
  //    TRooHStack::Draw 
  //    TRooHPdfStack::Draw 
  //
  //Extra Options available:
  //    init: use floatParsInit from TRooFitResult when drawing content + errors
  //    val: Draw the raw value (pdf density for TRooH1, or value for TRooHF1), as a TGraphErrors (you then usually include "AL" option) (samples 100 points)
  //    valXXXX (where XXXX is a number > 100): Same as above but can control the number of points sampled
  //    val hist: Draw raw value but as a histogram .. no error bar unless 'e' option included .. for TRooHF1 this is the same as no extra option
  

  TString opt = option;
  opt.ToLower();

  TRooFitResult* r2 = 0;
  
  if(r.floatParsFinal().getSize()|| r.constPars().getSize()) {
    if(opt.Contains("init")) {
      //request to draw initial parameters instead of final
      r2 = new TRooFitResult(r.floatParsInit());
      opt.ReplaceAll("init","");
    } else {
      r2 = new TRooFitResult(r.floatParsFinal());
    }
    r2->setConstParList(r.constPars());
  }
  
     // Draw this hist
   // if option contains 'pdf' then we draw as a graph instead

   bool found(false);
   
   TObject* me = dynamic_cast<TObject*>(this);
   
   if (gPad) {
      if (!gPad->IsEditable()) gROOT->MakeDefCanvas();
      if (!opt.Contains("same")) {
         //the following statement is necessary in case one attempts to draw
         //a temporary histogram already in the current pad
         if (me->TestBit(kCanDelete)) gPad->GetListOfPrimitives()->Remove(me);
         gPad->Clear();
         
         //also delete any DrawnHistograms that matched this pad:
         auto itr = fDrawHistograms.begin();
         while( itr != fDrawHistograms.end() ) {
          if(itr->pad==gPad) {
            if(itr->hist!=itr->postHist) SafeDelete(itr->postHist);
            SafeDelete(itr->hist);
            SafeDelete(itr->fr);
            fDrawHistograms.erase(itr);
          } else {
            ++itr;
          }
         }
      } else {
        //check if I'm already in the list of primitives ... if so, we wont add me a second time
        if(gPad->GetListOfPrimitives()->FindObject(me)) {
          gPad->Modified(true);
          found = true;
        }
      }
   }
   if(!found) me->AppendPad(opt.Data()); //will create gPad
   
   if(gPad->IsEditable()) {
    fDrawHistograms.emplace_back( DrawnHistogram() );
    fDrawHistograms.back().pad = gPad;
    if(opt.Contains("val")) {
      TGraph* g = 0;
      TH1* h = 0;
      
      if(opt.Contains("hist")) { //draw as hist instead
        h = TRooAbsH1::createOrAdjustHistogram( 0 );
        fDrawHistograms.back().hist = h;
        fillHistogram(h,r2,opt.Contains("e"));
        
        //divide by bin volume if we inherit from RooAbsPdf
        if(dynamic_cast<TObject*>(this)->InheritsFrom(RooAbsPdf::Class())) {
          for(int i=1;i<=h->GetNbinsX();i++) {
            for(int j=1;j<=h->GetNbinsY();j++) {
              for(int k=1;k<=h->GetNbinsZ();k++) {
                int bin = h->GetBin(i,j,k);
                double binVolume = h->GetXaxis()->GetBinWidth(i)*h->GetYaxis()->GetBinWidth(j)*h->GetZaxis()->GetBinWidth(k);
                h->SetBinContent(bin,h->GetBinContent(bin)/binVolume);
                h->SetBinError(bin,h->GetBinError(bin)/binVolume);
              }
            }
          }
        }
        //if use specified histhist option, then want to preserve one hist 
        opt.ReplaceAll("histhist","TMPSTRING");
        opt.ReplaceAll("hist","");
        opt.ReplaceAll("TMPSTRING","hist");
      } else {
        g = new TGraphErrors; //FIXME: at some point want to make with asymm errors
        g->SetName(GetName());g->SetTitle(GetTitle());
        fDrawHistograms.back().hist = g;
        TRooAbsH1::createOrAdjustHistogram( g->GetHistogram() );
        
        //check for an integer straight after pdf ... that will be the nPoints
        int nPoints = TString(opt(opt.Index("val")+3,opt.Length())).Atoi();
        if(nPoints>0) opt.ReplaceAll(Form("val%d",nPoints),"");
        fillGraph(g,r2,opt.Contains("e"), (nPoints>100) ? nPoints : 100);
        (*dynamic_cast<TAttFill*>(g)) = *this;
        (*dynamic_cast<TAttLine*>(g)) = *this;
        (*dynamic_cast<TAttMarker*>(g)) = *this;
        h = g->GetHistogram();
      }
      
      if(fObservables.getSize() && dynamic_cast<TObject*>(this)->InheritsFrom(RooAbsPdf::Class())) {
        RooAbsArg& arg = fObservables[0];
        RooAbsReal* argreal = dynamic_cast<RooAbsReal*>(&arg);
        
        TString myUnit = dynamic_cast<const RooAbsReal*>(this)->getUnit();
        if(argreal && strlen(argreal->getUnit())) {
          h->GetXaxis()->SetTitle(Form("%s [%s]",arg.GetTitle(),argreal->getUnit()));
          if(myUnit.Length()) myUnit += " ";
          myUnit += Form("%s^{-1}",argreal->getUnit());
        } else {
          h->GetXaxis()->SetTitle(arg.GetTitle());
        }
        
        if(myUnit.Length()) {
          h->GetYaxis()->SetTitle(Form("d%s/d%s [%s]",GetTitle(),arg.GetTitle(),myUnit.Data()));
        } else {
          h->GetYaxis()->SetTitle(Form("d%s/d%s",GetTitle(),arg.GetTitle()));
        }
      }
      
      opt.ReplaceAll("val","");
      
      if(opt.Contains("e") && opt.Contains("l") && g) {
        //want to ensure line appears above error band, so draw put a copy in the posthist ..
        fDrawHistograms.back().postHist = g;
        fDrawHistograms.back().postHistOpt = "lx"; //draws as line without error bars
      }
      
      if(opt.Contains("e3")) {
        int fillType = TString(opt(opt.Index("e3")+1,opt.Length())).Atoi();
        if(fillType>=3000 && fillType<=3999) {
          opt.ReplaceAll(TString::Format("e%d",fillType),"e3");
          g->SetFillStyle(fillType);g->SetFillColor(g->GetLineColor());
        }
        
      }
      
    } else { 
      TH1* hist = TRooAbsH1::createOrAdjustHistogram( 0 );
      fDrawHistograms.back().hist = hist;
      fillHistogram( hist , r2, true);
      
      
      
      
    }
    
    bool isInterpX = (((dynamic_cast<TObject*>(this)->InheritsFrom(TRooH1::Class()) && (dynamic_cast<TRooH1*>(this))->getObsInterpCode())
        || (dynamic_cast<TObject*>(this)->InheritsFrom(TRooHF1::Class()) && (dynamic_cast<TRooHF1*>(this))->getObsInterpCode())) && fObservables.getSize()==1);
    
    //if drawing with option "e3XXX" then will use that histogram as error bar histogram
    if(opt.Contains("e3") && fDrawHistograms.back().hist->InheritsFrom(TH1::Class())) {
      TH1* hist = static_cast<TH1*>(fDrawHistograms.back().hist);
      int fillType = TString(opt(opt.Index("e3")+1,opt.Length())).Atoi();
      if(fillType>=3000 && fillType<=3999 && hist->GetSumw2()->GetSum()) { //must have an error to draw an error bar hist
        TH1* errHist = (TH1*)hist->Clone(TString::Format("%s_error",hist->GetName()));
        errHist->SetFillStyle(fillType);errHist->SetMarkerStyle(0);errHist->SetFillColor(hist->GetLineColor());
        errHist->SetOption("e2same");
        fDrawHistograms.back().postHist = errHist;
        fDrawHistograms.back().postHistOpt = (isInterpX) ? "e3same" : "e2same";
        opt.ReplaceAll(TString::Format("e%d",fillType),"");
        //since we are showing error bar, the main hist should only be drawn as a line
        opt += "hist";
        //also if not drawing with 'same' option then draw axis of the hist, so that axis span the error bar 
        if(!opt.Contains("same")) {
          gPad->GetListOfPrimitives()->AddFirst( hist , "axis" ); //NOTE: sadly this means that the histogram title does not show up ... because this 'axis' version gets no title, but is drawn first
          opt += "same";
        }
      }
    }
    
    
    
    fDrawHistograms.back().opt = opt; //have to store opt separately because not all object types we can SetOption on
    fDrawHistograms.back().fr = r2;
    if(isInterpX && fDrawHistograms.back().hist->InheritsFrom(TH1::Class())) {
        if(!opt.Contains("e")) opt += "e0"; //the x0 option added below wont work without specifying an E
        opt += "lX0"; //will suppress horizonal error bars
    }
    gPad->GetListOfPrimitives()->Add( fDrawHistograms.back().hist , opt ); //adding histogram directly because cant figure out how to get clickable axis without it
    if(isInterpX && fDrawHistograms.back().hist->InheritsFrom(TH1::Class())) {
      gPad->GetListOfPrimitives()->Add( fDrawHistograms.back().hist , "Lx0hist same" ); //draws the lines between the points
      
    }
    if(fDrawHistograms.back().postHist) gPad->GetListOfPrimitives()->Add( fDrawHistograms.back().postHist , fDrawHistograms.back().postHistOpt ); 
   }
  
  
  

}


Double_t TRooAbsH1::missingEvents() const  { 
  //Get value of the missingEvents bin
  //EXPERIMENTAL FEATURE: do not use

  return (fMissingBin) ? fMissingBin->getVal() : 0.; 
}
